/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Solver"] = factory();
	else
		root["Solver"] = factory();
})(this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/common/Trie.js":
/*!****************************!*\
  !*** ./src/common/Trie.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Trie\": () => (/* binding */ Trie)\n/* harmony export */ });\n\n\nclass TrieNode {\n    constructor() {\n        this.isWord = false;\n    }\n}\n\nclass Trie {\n    constructor() {\n        this.root = new TrieNode();\n    }\n\n    insert(str) {\n        if (!str) return;\n        let currentNode = this.root;\n        for (let i = 0; i < str.length; i++) {\n            if (!currentNode[str[i]]) {\n                currentNode[str[i]] = new TrieNode();\n            }\n            currentNode = currentNode[str[i]];\n        }\n        currentNode.isWord = true;\n    }\n    contains(str) {\n        let currentNode = this.root;\n        for (let i = 0; i < str.length; i++) {\n            if (!currentNode[str[i]]) {\n                return false;\n            }\n            currentNode = currentNode[str[i]];\n        }\n        return currentNode.isWord;\n    }\n\n    findAll(str) {\n        const answer = [];\n        let currentNode = this.root;\n        let currentStr = \"\";\n        for (let i = 0; i < str.length; i++) {\n            const nextLetter = currentNode[str[i]];\n            currentStr += str[i];\n            if (!nextLetter) {\n                break;\n            }\n            if (nextLetter.isWord) {\n                answer.push(currentStr);\n            }\n            currentNode = nextLetter;\n        }\n        return answer;\n    }\n\n    dfs(possibleSets, index, currentNode, str, answer) {\n        if (index === possibleSets.length) {\n            if (currentNode.isWord) {\n                answer.push(str);\n            }\n            return;\n        }\n        const currentSet = possibleSets[index];\n        for (let i = 0; i < currentSet.length; i++) {\n            const currentLetter = currentSet[i];\n            const nextLetter = currentNode[currentLetter];\n            if (!nextLetter) {\n                continue;\n            }\n            this.dfs(possibleSets, index + 1, nextLetter, str + currentLetter, answer);\n        }\n    }\n\n    findAllByPossibleSets(possibleSets) {\n        const _possibleSets = [];\n        for (let i = 0; i < possibleSets.length; i++) {\n            const currentSet = possibleSets[i];\n            _possibleSets.push([...new Set(currentSet)]);\n        }\n        const answer = [];\n        this.dfs(_possibleSets, 0, this.root, \"\", answer);\n        return answer;\n    }\n}\n\n//# sourceURL=webpack://Solver/./src/common/Trie.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OneWord\": () => (/* reexport safe */ _one_word_one_word__WEBPACK_IMPORTED_MODULE_1__.OneWord),\n/* harmony export */   \"RubikCubeStage\": () => (/* reexport safe */ _rubic_cube_index__WEBPACK_IMPORTED_MODULE_3__.RubikCubeStage),\n/* harmony export */   \"SubstitutionSolver\": () => (/* reexport safe */ _substitution_substitution__WEBPACK_IMPORTED_MODULE_0__.SubstitutionSolver),\n/* harmony export */   \"SudokuSolver\": () => (/* reexport safe */ _sudoku_index__WEBPACK_IMPORTED_MODULE_4__.SudokuSolver),\n/* harmony export */   \"WordSearch\": () => (/* reexport safe */ _word_search_wordSearch__WEBPACK_IMPORTED_MODULE_2__.WordSearch)\n/* harmony export */ });\n/* harmony import */ var _substitution_substitution__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./substitution/substitution */ \"./src/substitution/substitution.js\");\n/* harmony import */ var _one_word_one_word__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./one-word/one-word */ \"./src/one-word/one-word.js\");\n/* harmony import */ var _word_search_wordSearch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./word-search/wordSearch */ \"./src/word-search/wordSearch.js\");\n/* harmony import */ var _rubic_cube_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rubic-cube/index */ \"./src/rubic-cube/index.js\");\n/* harmony import */ var _sudoku_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sudoku/index */ \"./src/sudoku/index.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://Solver/./src/index.js?");

/***/ }),

/***/ "./src/one-word/one-word.js":
/*!**********************************!*\
  !*** ./src/one-word/one-word.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OneWord\": () => (/* binding */ OneWord)\n/* harmony export */ });\n/* harmony import */ var _common_Trie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Trie */ \"./src/common/Trie.js\");\n\n\nclass OneWord {\n    constructor() {\n        this.initTrie();\n    }\n\n    initTrie() {\n        const words = window.words;\n        if (!window.Trie && words) {\n            window.Trie = new _common_Trie__WEBPACK_IMPORTED_MODULE_0__.Trie();\n            for (let patten in words) {\n                if (!patten) continue;\n                for (let word of words[patten]) {\n                    window.Trie.insert(word);\n                }\n            }\n        }\n        this.Trie = window.Trie;\n    }\n\n    editDistance(s1, s2) {\n        var row2 = [];\n        if (s1 === s2) {\n            return 0;\n        } else {\n            var s1_len = s1.length,\n                s2_len = s2.length;\n            if (s1_len && s2_len) {\n                var i1 = 0,\n                    i2 = 0,\n                    a,\n                    b,\n                    c,\n                    c2,\n                    row = row2;\n                while (i1 < s1_len) row[i1] = ++i1;\n                while (i2 < s2_len) {\n                    c2 = s2.charCodeAt(i2);\n                    a = i2;\n                    ++i2;\n                    b = i2;\n                    for (i1 = 0; i1 < s1_len; ++i1) {\n                        c = a + (s1.charCodeAt(i1) === c2 ? 0 : 1);\n                        a = row[i1];\n                        b = b < a ? b < c ? b + 1 : c : a < c ? a + 1 : c;\n                        row[i1] = b;\n                    }\n                }\n                return b;\n            } else {\n                return s1_len + s2_len;\n            }\n        }\n    }\n\n    async findByRegularExpression(str, callback, filter) {\n        const words = window.words;\n        const regularExpression = eval(`/${str}/`);\n        const answer = [];\n        if (!callback) {\n            callback = () => {};\n        }\n        for (let pattern in words) {\n            if (!pattern) continue;\n            const len = pattern.length;\n            for (let i = 0; i < words[pattern].length; i++) {\n                const word = words[pattern][i];\n                if (this.isFilter(pattern, i, filter)) continue;\n                if (regularExpression.test(word)) {\n                    answer.push(word);\n                    await callback(len, word);\n                }\n            }\n        }\n        return answer;\n    }\n\n    findByWildcard(wildcard, callback, filter) {\n        let regx = '';\n        const parseWildcard = wildcard => {\n            const wildcardObj = [];\n            const len = wildcard.length;\n            let regex = '';\n            for (let i = 0; i < len; i++) {\n                if (x == '*') {\n                    regex += '.*';\n                } else if (x == '[') {\n                    i++;\n                    while (i < len && wildcard[i] != ']') {\n                        regex += wildcard[i];\n                    }\n                } else if (isLowerCase(x)) {\n                    regex += x;\n                } else regex += '.';\n                wildcardObj.push(regex);\n            }\n            return wildcardObj;\n        };\n\n        const wildcards = parseWildcard(wildcard);\n\n        console.info(wildcards);\n\n        for (const w of wildcards) {\n            this.findByRegularExpression(`^${w}$`, callback, filter);\n        }\n\n        for (let x of wildcard) {\n            if (x === '#') {\n                regx += '.';\n            } else if (x === '*') {\n                regx += '.*';\n            } else {\n                regx += x;\n            }\n        }\n        return this.findByRegularExpression(`^${regx}$`, callback, filter);\n    }\n\n    isFilter(patten, index, filter) {\n        if (!window.c) return false;\n        if (!window.c[patten]) {\n            return false;\n        }\n        if ((filter & 16) === 0 && (window.c[patten][index] & 16) === 0) return true;\n        if ((filter & window.c[patten][index]) != 0) {\n            return false;\n        }\n        return true;\n    }\n\n    makeLetterSet(str) {\n        const letterSet = [];\n        for (let i = 0; i < str.length; i++) {\n            if (!letterSet[str[i]]) {\n                letterSet[str[i]] = 0;\n            }\n            letterSet[str[i]]++;\n        }\n        return letterSet;\n    }\n\n    async onlyContains(letters, callback) {\n        const words = window.words;\n        const answer = [];\n        const letterSet = this.makeLetterSet(letters);\n        const containsHelp = (letterSet, str) => {\n            const letterCount = [];\n            for (let i = 0; i < str.length; i++) {\n                if (!letterSet[str[i]]) {\n                    return false;\n                }\n                if (!letterCount[str[i]]) {\n                    letterCount[str[i]] = 0;\n                }\n                letterCount[str[i]]++;\n            }\n            return true;\n        };\n        for (let patten in words) {\n            if (!patten) continue;\n            const len = patten.length;\n            for (let word of words[patten]) {\n                if (containsHelp(letterSet, word)) {\n                    await callback(len, word);\n                    answer.push(word);\n                }\n            }\n        }\n        return answer;\n    }\n\n    permutation(letters) {\n        const words = window.words;\n        const answer = [];\n        const letterSet = this.makeLetterSet(letters);\n        const containsHelp = (letterSet, str) => {\n            const letterCount = [];\n            for (let i = 0; i < str.length; i++) {\n                if (!letterSet[str[i]]) {\n                    return false;\n                }\n                if (!letterCount[str[i]]) {\n                    letterCount[str[i]] = 0;\n                }\n                letterCount[str[i]]++;\n            }\n            for (let letter in letterSet) {\n                if (!letterCount[letter] || letterSet[letter] != letterCount[letter]) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        for (let patten in words) {\n            if (!patten) continue;\n            for (let word of words[patten]) {\n                if (containsHelp(letterSet, word)) {\n                    console.info(word);\n                    answer.push(word);\n                }\n            }\n        }\n        return answer;\n    }\n\n    stringInclude(letterSet, str) {\n        const letterCount = [];\n        for (let i = 0; i < str.length; i++) {\n            if (!letterSet[str[i]]) continue;\n            if (!letterCount[str[i]]) {\n                letterCount[str[i]] = 0;\n            }\n            letterCount[str[i]]++;\n        }\n        for (let letter in letterSet) {\n            if (!letterCount[letter] || letterSet[letter] > letterCount[letter]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    async contains(letters, callback) {\n        const words = window.words;\n        const answers = [];\n        if (!callback) {\n            callback = () => {};\n        }\n\n        const containsHelp = (letterSet, str) => {\n            const letterCount = [];\n            for (let i = 0; i < str.length; i++) {\n                if (!letterSet[str[i]]) {\n                    return false;\n                }\n                if (!letterCount[str[i]]) {\n                    letterCount[str[i]] = 0;\n                }\n                letterCount[str[i]]++;\n            }\n            return true;\n        };\n        const letterSet = this.makeLetterSet(letters);\n        for (let patten in words) {\n            if (!patten) continue;\n            const len = patten.length;\n            for (let word of words[patten]) {\n                if (this.stringInclude(letterSet, word) || containsHelp(letterSet, word)) {\n                    answers.push(word);\n                    await callback(len, word);\n                }\n            }\n        }\n        return answers;\n    }\n\n    async findSimilarity(str, similarityDegree, callback) {\n        const words = window.words;\n        const answer = [];\n        if (!similarityDegree) {\n            similarityDegree = 1;\n        }\n        if (!callback) {\n            callback = () => {};\n        }\n        const strLen = str.length;\n        for (let patten in words) {\n            if (!patten) continue;\n            const wordLen = patten.length;\n            if (Math.abs(wordLen - strLen) > similarityDegree) continue;\n            for (let word of words[patten]) {\n                if (this.editDistance(str, word) <= similarityDegree) {\n                    answer.push(word);\n                    await callback(wordLen, word);\n                }\n            }\n        }\n        return answer;\n    }\n\n    async findByCode(code, callback) {\n        const words = window.words;\n        const answer = [];\n        if (!callback) {\n            callback = () => {};\n        }\n        const tools = {\n            isWord: str => {\n                return this.Trie.contains(str);\n            },\n            anagram: (str, letters) => {\n                const letterSet = this.makeLetterSet(letters);\n                return this.stringInclude(letterSet, str);\n            }\n        };\n        try {\n            var func = new Function(`return ${code}`)();\n            if (!func) {\n                throw new Error(\"没有函数\");\n            }\n        } catch (e) {\n            alert(`程序错误，请仔细检查你的代码\\n错误信息:\\n${e.message}`);\n            throw e;\n        }\n        for (let pattern in words) {\n            if (!pattern) continue;\n            for (let word of words[pattern]) {\n                let ret;\n                try {\n                    ret = func(word, tools);\n                } catch (e) {\n                    continue;\n                }\n                if (ret) {\n                    answer.push(ret);\n                    await callback(ret.length, ret);\n                }\n            }\n        }\n        console.info(code);\n    }\n\n}\n\n//# sourceURL=webpack://Solver/./src/one-word/one-word.js?");

/***/ }),

/***/ "./src/rubic-cube/cube.js":
/*!********************************!*\
  !*** ./src/rubic-cube/cube.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Cube\": () => (/* binding */ Cube)\n/* harmony export */ });\n/* harmony import */ var _rectangle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rectangle */ \"./src/rubic-cube/rectangle.js\");\n/* harmony import */ var _point3D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point3D */ \"./src/rubic-cube/point3D.js\");\n\n\n\nclass Cube {\n\tconstructor(position, len, colors, index) {\n\t\tthis.index = index;\n\t\tif (!colors) {\n\t\t\tcolors = [];\n\t\t}\n\t\tconst points = [];\n\t\tfor (let i = 0; i < 8; i++) {\n\t\t\tpoints.push(new _point3D__WEBPACK_IMPORTED_MODULE_1__.Point3D(position.x + (i & 1) * len, position.y + (i >> 1 & 1) * len, position.z + (i >> 2 & 1) * len));\n\t\t}\n\t\t//up, back, bottom, front, \"right\", left\n\t\t//white, orange, yellow, red, blue, green\n\t\tconst faceIndex = [[2, 0, 1, 3], [5, 7, 3, 1], [4, 6, 7, 5], [6, 4, 0, 2], [7, 6, 2, 3], [4, 5, 1, 0]];\n\t\tthis.faces = [];\n\t\tconst faceIndexCount = faceIndex.length;\n\t\tconst isPointUsed = [];\n\t\tlet faceIndexNum = 0;\n\t\tfor (let i = 0; i < faceIndexCount; i++) {\n\t\t\tif (colors[i] === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisPointUsed[faceIndex[i][0]] = true;\n\t\t\tisPointUsed[faceIndex[i][1]] = true;\n\t\t\tisPointUsed[faceIndex[i][2]] = true;\n\t\t\tisPointUsed[faceIndex[i][3]] = true;\n\t\t\tconst face = new _rectangle__WEBPACK_IMPORTED_MODULE_0__.Rectangle(points[faceIndex[i][0]], points[faceIndex[i][1]], points[faceIndex[i][2]], points[faceIndex[i][3]], len, colors[i], faceIndexNum++);\n\t\t\tthis.faces.push(face);\n\t\t}\n\t\tthis.points = [];\n\t\tfor (let i = 0; i < 8; i++) {\n\t\t\tif (isPointUsed[i] === true) {\n\t\t\t\tthis.points.push(points[i]);\n\t\t\t}\n\t\t}\n\t}\n\trender(ctx, materials) {\n\t\tfor (let face of this.faces) {\n\t\t\tlet material = materials ? materials[face.index] : null;\n\t\t\tface.render(ctx, this.index, material);\n\t\t}\n\t}\n\trotate(angle, axis, op) {\n\t\tfor (let point of this.points) {\n\t\t\tpoint.rotate(angle, axis, op);\n\t\t}\n\t}\n\tresetRotation() {\n\t\tfor (let point of this.points) {\n\t\t\tpoint.resetRotation();\n\t\t}\n\t}\n}\n\n//# sourceURL=webpack://Solver/./src/rubic-cube/cube.js?");

/***/ }),

/***/ "./src/rubic-cube/index.js":
/*!*********************************!*\
  !*** ./src/rubic-cube/index.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RubikCubeStage\": () => (/* binding */ RubikCubeStage)\n/* harmony export */ });\n/* harmony import */ var _point3D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point3D */ \"./src/rubic-cube/point3D.js\");\n/* harmony import */ var _rubikCube__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rubikCube */ \"./src/rubic-cube/rubikCube.js\");\n\n\n\nclass Scene {\n    constructor(ctx) {\n        this.objList = [];\n        this.ctx = ctx;\n    }\n    add(obj) {\n        this.objList.push(obj);\n    }\n    render() {\n        for (let obj of this.objList) {\n            obj.render(this.ctx);\n        }\n    }\n}\n\nclass RubikCubeStage {\n    constructor(ctx, width, height, blocks) {\n        this.ctx = ctx;\n        this.width = width;\n        this.height = height;\n        this.rotationAngle = { x: 20, y: 20, z: 20 };\n        const len = 150;\n        const materials = this.makeMaterials(blocks);\n        this.cube = new _rubikCube__WEBPACK_IMPORTED_MODULE_1__.RubikCube(new _point3D__WEBPACK_IMPORTED_MODULE_0__.Point3D(-len / 2, -len / 2, -len / 2), len, 3, materials);\n        this.rotate(this.rotationAngle);\n        this.draw(this.rotationAngle);\n        this.register();\n    }\n\n    makeMaterials(blocks) {\n        const blockIndexMap = [{ index: 0, arr: [6, 18, 11] }, { index: 1, arr: [21, 14] }, { index: 2, arr: [36, 24, 17] }, { index: 3, arr: [7, 19] }, { index: 4, arr: [22] }, { index: 5, arr: [37, 25] }, { index: 6, arr: [8, 20, 27] }, { index: 7, arr: [23, 30] }, { index: 8, arr: [38, 26, 33] }, { index: 9, arr: [3, 10] }, { index: 10, arr: [13] }, { index: 11, arr: [39, 16] }, { index: 12, arr: [4] }, { index: 13, arr: [40] }, { index: 14, arr: [5, 28] }, { index: 15, arr: [31] }, { index: 16, arr: [41, 34] }, { index: 17, arr: [0, 51, 9] }, { index: 18, arr: [48, 12] }, { index: 19, arr: [45, 42, 15] }, { index: 20, arr: [1, 52] }, { index: 21, arr: [49] }, { index: 22, arr: [46, 43] }, { index: 23, arr: [2, 53, 29] }, { index: 24, arr: [50, 32] }, { index: 25, arr: [47, 44, 35] }];\n        const ret = [];\n        for (let blockIndexs of blockIndexMap) {\n            ret[blockIndexs.index] = [];\n            for (let blockIndex of blockIndexs.arr) {\n                ret[blockIndexs.index].push(blocks[blockIndex]);\n            }\n        }\n        return ret;\n    }\n    rotate(rotationAngle) {\n        this.rotationAngle = {\n            x: this.rotationAngle.x + rotationAngle.x,\n            y: this.rotationAngle.y + rotationAngle.y,\n            z: this.rotationAngle.z + rotationAngle.z\n        };\n        const cube = this.cube;\n        cube.rotate(rotationAngle.x, 'x');\n        cube.rotate(rotationAngle.y, 'y');\n        cube.rotate(rotationAngle.z, 'z');\n    }\n    draw() {\n        const cube = this.cube;\n        this.ctx.clearRect(0, 0, this.width, this.height);\n        const scene = new Scene(this.ctx);\n        scene.add(cube);\n        scene.render();\n    }\n    resetRotation() {\n        this.cube.resetRotation();\n    }\n    front(inverse) {\n        if (!inverse) inverse = 1;\n        this.cube.front(inverse);\n        this.draw();\n    }\n    up(inverse) {\n        if (!inverse) inverse = 1;\n        this.cube.up(inverse);\n        this.draw();\n    }\n    back(inverse) {\n        if (!inverse) inverse = 1;\n        this.cube.back(inverse);\n        this.draw();\n    }\n    bottom(inverse) {\n        if (!inverse) inverse = 1;\n        this.cube.bottom(inverse);\n        this.draw();\n    }\n    left(inverse) {\n        if (!inverse) inverse = 1;\n        this.cube.left(inverse);\n        this.draw();\n    }\n    right(inverse) {\n        if (!inverse) inverse = 1;\n        this.cube.right(inverse);\n        this.draw();\n    }\n    register() {\n        const rubicCubeStage = this;\n        let originCoordinate = {};\n        let ppMousePressed = false;\n        $('#rubik-cube').mousedown(e => {\n            if (e.which === 1) // left click\n                {\n                    var mouseX = e.pageX;\n                    var mouseY = e.pageY;\n                    if (ppMousePressed === false) {\n                        originCoordinate.x = mouseX;\n                        originCoordinate.y = mouseY;\n                    }\n                    ppMousePressed = true;\n                }\n        });\n\n        $('body').mouseup(e => {\n            if (ppMousePressed === true) {\n                ppMousePressed = false;\n                rubicCubeStage.resetRotation();\n                const rotationAngle = { x: 20, y: 20, z: 20 };\n                rubicCubeStage.rotate(rotationAngle);\n                rubicCubeStage.draw();\n            }\n        });\n\n        $('body').mousemove(e => {\n            if (ppMousePressed === true) {\n                const rotationAngle = { x: 0, y: 0, z: 0 };\n                let mouseX = e.pageX;\n                let mouseY = e.pageY;\n                let diffX = mouseX - originCoordinate.x;\n                let diffY = mouseY - originCoordinate.y;\n                rotationAngle.z = -diffX;\n                rotationAngle.y = diffY;\n                rubicCubeStage.rotate(rotationAngle);\n                rubicCubeStage.draw();\n                originCoordinate.x = mouseX;\n                originCoordinate.y = mouseY;\n            }\n        });\n\n        $('#rubik-cube').on(\"touchstart\", function (e) {\n            var mouseX = e.originalEvent.changedTouches[0].pageX;\n            var mouseY = e.originalEvent.changedTouches[0].pageY;\n            if (ppMousePressed === false) {\n                originCoordinate.x = mouseX;\n                originCoordinate.y = mouseY;\n            }\n            ppMousePressed = true;\n            e.preventDefault();\n        });\n\n        $('#rubik-cube').on(\"touchend\", function (e) {\n            if (ppMousePressed === true) {\n                ppMousePressed = false;\n                rubicCubeStage.resetRotation();\n                const rotationAngle = { x: 20, y: 20, z: 20 };\n                rubicCubeStage.rotate(rotationAngle);\n                rubicCubeStage.draw();\n                e.preventDefault();\n            }\n        });\n        $('#rubik-cube').on(\"touchmove\", function (e) {\n            if (ppMousePressed === true) {\n                const rotationAngle = { x: 0, y: 0, z: 0 };\n                var mouseX = e.originalEvent.changedTouches[0].pageX;\n                var mouseY = e.originalEvent.changedTouches[0].pageY;\n                let diffX = mouseX - originCoordinate.x;\n                let diffY = mouseY - originCoordinate.y;\n                rotationAngle.z = -diffX;\n                rotationAngle.y = diffY;\n                rubicCubeStage.rotate(rotationAngle);\n                rubicCubeStage.draw();\n                console.info(diffX);\n                originCoordinate.x = mouseX;\n                originCoordinate.y = mouseY;\n            }\n        });\n\n        var ppPoint = function (x, y) {\n            this.x = x;\n            this.y = y;\n        };\n        let blockMousePressed = false;\n        let ppPointArray = new Array();\n        $('.cube-block').mousedown(function (e) {\n            if (e.which == 1) // 如果是左键\n                {\n                    blockMousePressed = true;\n                    var mouseX = e.pageX - this.offsetLeft;\n                    var mouseY = e.pageY - this.offsetTop;\n                    ppPointArray.push(new ppPoint(mouseX, mouseY));\n\n                    $(e.target).mousemove(function (eve) {\n                        if (blockMousePressed) {\n                            var mouseX = eve.pageX - this.offsetLeft;\n                            var mouseY = eve.pageY - this.offsetTop;\n                            ppDrawLine(mouseX, mouseY, eve.currentTarget.getContext(\"2d\"));\n                        }\n                    });\n\n                    $(window).mouseup(function (e) {\n                        blockMousePressed = false;\n                        rubicCubeStage.draw();\n                        $(e.target).off(\"mousemove\");\n                    });\n                }\n        });\n\n        $('.cube-block').on(\"touchstart\", function (e) {\n            var mouseX = e.originalEvent.changedTouches[0].pageX - this.offsetLeft;\n            var mouseY = e.originalEvent.changedTouches[0].pageY - this.offsetTop;\n            blockMousePressed = true;\n            ppPointArray.push(new ppPoint(mouseX, mouseY));\n            e.preventDefault();\n            $(e.target).on(\"touchmove\", function (eve) {\n                if (blockMousePressed) {\n                    var mouseX = eve.originalEvent.changedTouches[0].pageX - this.offsetLeft;\n                    var mouseY = eve.originalEvent.changedTouches[0].pageY - this.offsetTop;\n                    ppDrawLine(mouseX, mouseY, eve.currentTarget.getContext(\"2d\"));\n                }\n            });\n\n            $(window).mouseup(function (e) {\n                blockMousePressed = false;\n                rubicCubeStage.draw();\n                $(e.target).off(\"touchmove\");\n            });\n        });\n\n        function ppDrawLine(curX, curY, context) {\n            const color = $('#penColor').val();\n            context.strokeStyle = color;\n            const width = $('#penWidth').val();\n            context.lineWidth = parseInt(width);\n            context.beginPath();\n            var ppLastPoint = ppPointArray[ppPointArray.length - 1];\n            context.moveTo(ppLastPoint.x, ppLastPoint.y);\n            context.lineTo(curX, curY);\n            context.closePath();\n            context.stroke();\n            ppPointArray.push(new ppPoint(curX, curY));\n        }\n    }\n}\n\n//# sourceURL=webpack://Solver/./src/rubic-cube/index.js?");

/***/ }),

/***/ "./src/rubic-cube/point3D.js":
/*!***********************************!*\
  !*** ./src/rubic-cube/point3D.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Point3D\": () => (/* binding */ Point3D)\n/* harmony export */ });\nclass Point3D {\n\tconstructor(x, y, z) {\n\t\tthis.angleX = 0;\n\t\tthis.angleY = 0;\n\t\tthis.angleZ = 0;\n\t\tthis.originX = x;\n\t\tthis.originY = y;\n\t\tthis.originZ = z;\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];\n\t}\n\tmultiply(mat1, mat2) {\n\t\tconst ret = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];\n\t\tfor (let i = 0; i < 3; i++) {\n\t\t\tfor (let j = 0; j < 3; j++) {\n\t\t\t\tfor (let k = 0; k < 3; k++) {\n\t\t\t\t\tret[i][j] += mat1[i][k] * mat2[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\trotateHelp(angleRad, axis) {\n\t\tlet newX = this.originX,\n\t\t    newY = this.originY,\n\t\t    newZ = this.originZ;\n\t\tswitch (axis) {\n\t\t\tcase \"x\":\n\t\t\t\t{\n\t\t\t\t\tnewY = this.originY * Math.cos(angleRad) - this.originZ * Math.sin(angleRad);\n\t\t\t\t\tnewZ = this.originY * Math.sin(angleRad) + this.originZ * Math.cos(angleRad);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase \"y\":\n\t\t\t\t{\n\t\t\t\t\tnewX = this.originX * Math.cos(angleRad) + this.originZ * Math.sin(angleRad);\n\t\t\t\t\tnewZ = -this.originX * Math.sin(angleRad) + this.originZ * Math.cos(angleRad);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase \"z\":\n\t\t\t\t{\n\t\t\t\t\tnewX = this.originX * Math.cos(angleRad) - this.originY * Math.sin(angleRad);\n\t\t\t\t\tnewY = this.originX * Math.sin(angleRad) + this.originY * Math.cos(angleRad);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tthis.originX = newX;\n\t\tthis.originY = newY;\n\t\tthis.originZ = newZ;\n\t}\n\trotate(angle, axis, op) {\n\t\tconst mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];\n\t\tconst angleRad = angle * Math.PI / 180;\n\t\tif (op === true) {\n\t\t\tthis.rotateHelp(angleRad, axis);\n\t\t} else switch (axis) {\n\t\t\tcase \"x\":\n\t\t\t\t{\n\t\t\t\t\tmat[1][1] = Math.cos(angleRad);\n\t\t\t\t\tmat[1][2] = -Math.sin(angleRad);\n\t\t\t\t\tmat[2][1] = Math.sin(angleRad);\n\t\t\t\t\tmat[2][2] = Math.cos(angleRad);\n\t\t\t\t\tthis.angleX += angle;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase \"y\":\n\t\t\t\t{\n\t\t\t\t\tmat[0][0] = Math.cos(angleRad);\n\t\t\t\t\tmat[2][0] = -Math.sin(angleRad);\n\t\t\t\t\tmat[0][2] = Math.sin(angleRad);\n\t\t\t\t\tmat[2][2] = Math.cos(angleRad);\n\t\t\t\t\tthis.angleY += angle;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tcase \"z\":\n\t\t\t\t{\n\t\t\t\t\tmat[0][0] = Math.cos(angleRad);\n\t\t\t\t\tmat[0][1] = -Math.sin(angleRad);\n\t\t\t\t\tmat[1][0] = Math.sin(angleRad);\n\t\t\t\t\tmat[1][1] = Math.cos(angleRad);\n\t\t\t\t\tthis.angleZ += angle;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tthis.mat = this.multiply(this.mat, mat);\n\t\tconst xx = this.originX * this.mat[0][0] + this.originY * this.mat[0][1] + this.originZ * this.mat[0][2];\n\t\tconst yy = this.originX * this.mat[1][0] + this.originY * this.mat[1][1] + this.originZ * this.mat[1][2];\n\t\tconst zz = this.originX * this.mat[2][0] + this.originY * this.mat[2][1] + this.originZ * this.mat[2][2];\n\t\tthis.x = xx;\n\t\tthis.y = yy;\n\t\tthis.z = zz;\n\t}\n\tresetRotation() {\n\t\tthis.mat = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];\n\t\tthis.rotate(\"x\", 0);\n\t}\n}\n\n//# sourceURL=webpack://Solver/./src/rubic-cube/point3D.js?");

/***/ }),

/***/ "./src/rubic-cube/rectangle.js":
/*!*************************************!*\
  !*** ./src/rubic-cube/rectangle.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Rectangle\": () => (/* binding */ Rectangle)\n/* harmony export */ });\n/* harmony import */ var _point3D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point3D */ \"./src/rubic-cube/point3D.js\");\n\n\nclass Rectangle {\n\tconstructor(a, b, c, d, len, color, index) {\n\t\tthis.points = [a, b, c, d];\n\t\tthis.len = len;\n\t\tif (!color) {\n\t\t\tcolor = \"red\";\n\t\t}\n\t\tthis.color = color;\n\t\tthis.index = index;\n\t}\n\trender(ctx, index, material) {\n\t\tconst v1 = new _point3D__WEBPACK_IMPORTED_MODULE_0__.Point3D(this.points[1].x - this.points[0].x, this.points[1].y - this.points[0].y, this.points[1].z - this.points[0].z);\n\t\tconst v2 = new _point3D__WEBPACK_IMPORTED_MODULE_0__.Point3D(this.points[3].x - this.points[0].x, this.points[3].y - this.points[0].y, this.points[3].z - this.points[0].z);\n\t\tvar normalP3D = new _point3D__WEBPACK_IMPORTED_MODULE_0__.Point3D(v1.y * v2.z - v2.y * v1.z, v1.z * v2.x - v2.z * v1.x, v1.x * v2.y - v2.x * v1.y);\n\t\tif (normalP3D.x <= 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst offset = 150;\n\t\tconst p1 = new _point3D__WEBPACK_IMPORTED_MODULE_0__.Point3D(this.points[0].y + offset, this.points[0].z + offset);\n\t\tconst p2 = new _point3D__WEBPACK_IMPORTED_MODULE_0__.Point3D(this.points[1].y + offset, this.points[1].z + offset);\n\t\tconst p3 = new _point3D__WEBPACK_IMPORTED_MODULE_0__.Point3D(this.points[2].y + offset, this.points[2].z + offset);\n\t\tconst p4 = new _point3D__WEBPACK_IMPORTED_MODULE_0__.Point3D(this.points[3].y + offset, this.points[3].z + offset);\n\t\tctx.beginPath();\n\t\tctx.moveTo(this.points[0].y + offset, this.points[0].z + offset);\n\t\tctx.lineTo(this.points[1].y + offset, this.points[1].z + offset);\n\t\tctx.lineTo(this.points[2].y + offset, this.points[2].z + offset);\n\t\tctx.lineTo(this.points[3].y + offset, this.points[3].z + offset);\n\t\tctx.lineTo(this.points[0].y + offset, this.points[0].z + offset);\n\t\tctx.lineWidth = 1;\n\t\tctx.stroke();\n\t\tlet u = Math.sqrt((p1.x - p4.x) * (p1.x - p4.x) + (p1.y - p4.y) * (p1.y - p4.y)) / this.len;\n\t\tu = (p1.y - p4.y) / this.len;\n\t\tlet v = -(p2.x - p1.x) / this.len;\n\t\tlet uu = (p2.y - p1.y) / (p2.x - p1.x);\n\t\tlet vv = (p4.x - p1.x) / (p4.y - p1.y);\n\t\tif (Math.abs(p4.y - p1.y) < 0.0000001) {\n\t\t\tvv = 0;\n\t\t}\n\t\tctx.setTransform(v, uu * v, vv * u, u, this.points[3].y + offset, this.points[3].z + offset);\n\t\tctx.fillStyle = this.color;\n\t\t/*\r\n  var img=document.getElementById(\"scream\");\r\n  ctx.drawImage(img,0,0, this.len,this.len);\r\n  */\n\t\tif (material) {\n\t\t\tctx.drawImage(material, -this.len, 0, this.len, this.len);\n\t\t} else {\n\t\t\tctx.fillRect(-this.len, 0, this.len, this.len);\n\t\t}\n\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\n\t\t//ctx.fillRect(0,0,this.len,this.len);\n\t}\n\n}\n\n//# sourceURL=webpack://Solver/./src/rubic-cube/rectangle.js?");

/***/ }),

/***/ "./src/rubic-cube/rubikCube.js":
/*!*************************************!*\
  !*** ./src/rubic-cube/rubikCube.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RubikCube\": () => (/* binding */ RubikCube)\n/* harmony export */ });\n/* harmony import */ var _point3D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point3D */ \"./src/rubic-cube/point3D.js\");\n/* harmony import */ var _cube__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cube */ \"./src/rubic-cube/cube.js\");\n\n\n\nclass RubikCube {\n\tontheEdge(index) {\n\t\tif (index === 0) return true;\n\t\tif (index === this.degree - 1) return true;\n\t\treturn false;\n\t}\n\tconstructor(position, len, degree, materials) {\n\t\tif (!degree) {\n\t\t\tdegree = 3;\n\t\t}\n\t\tthis.degree = degree;\n\t\tthis.blockSize = len / degree;\n\t\tthis.materials = materials;\n\t\tthis.cubes = [];\n\t\tconst defaultColor = [\"white\", \"orange\", \"yellow\", \"red\", \"blue\", \"green\"];\n\t\tlet index = 0;\n\t\tfor (let i = 0; i < degree; i++) {\n\t\t\tfor (let j = 0; j < degree; j++) {\n\t\t\t\tfor (let k = 0; k < degree; k++) {\n\t\t\t\t\tif (!this.ontheEdge(i) && !this.ontheEdge(j) && !this.ontheEdge(k)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst pos = new _point3D__WEBPACK_IMPORTED_MODULE_0__.Point3D(position.x + i * this.blockSize, position.y + j * this.blockSize, position.z + k * this.blockSize);\n\t\t\t\t\tconst colors = defaultColor.slice(0);\n\t\t\t\t\tif (k != 0) colors[0] = null;\n\t\t\t\t\tif (k != degree - 1) colors[2] = null;\n\t\t\t\t\tif (i != degree - 1) colors[1] = null;\n\t\t\t\t\tif (i != 0) colors[3] = null;\n\t\t\t\t\tif (j != degree - 1) colors[4] = null;\n\t\t\t\t\tif (j != 0) colors[5] = null;\n\t\t\t\t\tconst cube = new _cube__WEBPACK_IMPORTED_MODULE_1__.Cube(pos, this.blockSize, colors, index++);\n\t\t\t\t\tthis.cubes.push(cube);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trender(ctx) {\n\t\tconst cubes = this.cubes.slice(0);\n\t\tcubes.sort((a, b) => b.points[0].x - a.points[0].x);\n\t\tfor (let cube of cubes) {\n\t\t\tconst material = this.materials ? this.materials[cube.index] : null;\n\t\t\tcube.render(ctx, material);\n\t\t}\n\t}\n\trotate(angle, axis) {\n\t\tfor (let cube of this.cubes) {\n\t\t\tcube.rotate(angle, axis);\n\t\t}\n\t}\n\tresetRotation() {\n\t\tfor (let cube of this.cubes) {\n\t\t\tcube.resetRotation();\n\t\t}\n\t}\n\tpermutation(permutationTable, inverse) {\n\t\tfor (let item of permutationTable) {\n\t\t\tconst len = item.length;\n\t\t\tif (inverse === 1) {\n\t\t\t\tfor (let i = 0; i < len - 1; i++) {\n\t\t\t\t\tconst tmp = this.cubes[item[i]];\n\t\t\t\t\tthis.cubes[item[i]] = this.cubes[item[i + 1]];\n\t\t\t\t\tthis.cubes[item[i + 1]] = tmp;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = len - 1; i >= 1; i--) {\n\t\t\t\t\tconst tmp = this.cubes[item[i]];\n\t\t\t\t\tthis.cubes[item[i]] = this.cubes[item[i - 1]];\n\t\t\t\t\tthis.cubes[item[i - 1]] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trotateLayer(permutationTable, inverse, axis) {\n\t\tfor (let item of permutationTable) {\n\t\t\tconst len = item.length;\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tthis.cubes[item[i]].rotate(90 * inverse, axis, true);\n\t\t\t}\n\t\t}\n\t}\n\tfront(inverse) {\n\t\tconst permutationTable = [[2, 8, 6, 0], [1, 5, 7, 3], [4]];\n\t\tthis.rotateLayer(permutationTable, inverse, \"x\");\n\t\tthis.permutation(permutationTable, inverse);\n\t}\n\tup(inverse) {\n\t\tconst permutationTable = [[0, 6, 23, 17], [3, 14, 20, 9], [12]];\n\t\tthis.rotateLayer(permutationTable, inverse, \"z\");\n\t\tthis.permutation(permutationTable, inverse);\n\t}\n\tback(inverse) {\n\t\tconst permutationTable = [[22, 24, 20, 18], [19, 25, 23, 17], [21]];\n\t\tthis.rotateLayer(permutationTable, inverse, \"x\");\n\t\tthis.permutation(permutationTable, inverse);\n\t}\n\tbottom(inverse) {\n\t\tconst permutationTable = [[11, 5, 16, 22], [19, 2, 8, 25], [13]];\n\t\tthis.rotateLayer(permutationTable, inverse, \"z\");\n\t\tthis.permutation(permutationTable, inverse);\n\t}\n\tleft(inverse) {\n\t\tconst permutationTable = [[0, 17, 19, 2], [1, 9, 18, 11], [10]];\n\t\tthis.rotateLayer(permutationTable, inverse, \"y\");\n\t\tthis.permutation(permutationTable, inverse);\n\t}\n\tright(inverse) {\n\t\tconst permutationTable = [[8, 6, 23, 25], [16, 7, 14, 24], [15]];\n\t\tthis.rotateLayer(permutationTable, inverse, \"y\");\n\t\tthis.permutation(permutationTable, inverse);\n\t}\n}\n\n//# sourceURL=webpack://Solver/./src/rubic-cube/rubikCube.js?");

/***/ }),

/***/ "./src/substitution/MappingTable.js":
/*!******************************************!*\
  !*** ./src/substitution/MappingTable.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MappingTable\": () => (/* binding */ MappingTable)\n/* harmony export */ });\nclass MappingTable {\n\tconstructor() {\n\t\tthis.mode = MappingTable.impossible;\n\t\tthis.matrix = new Array(26);\n\t\tthis.ensure = new Array(26);\n\t\tfor (let i = 0; i < 26; i++) {\n\t\t\tthis.matrix[String.fromCharCode(97 + i)] = new Array(26);\n\t\t\tlet curCol = this.matrix[String.fromCharCode(97 + i)];\n\t\t\tfor (let j = 0; j < 26; j++) {\n\t\t\t\tcurCol[String.fromCharCode(97 + j)] = MappingTable.possible;\n\t\t\t}\n\t\t}\n\t}\n\n\tinit() {\n\t\tthis.matrix = new Array(26);\n\t\tthis.ensure = new Array(26);\n\t\tfor (let i = 0; i < 26; i++) {\n\t\t\tthis.matrix[String.fromCharCode(97 + i)] = new Array(26);\n\t\t\tlet curCol = this.matrix[String.fromCharCode(97 + i)];\n\t\t\tfor (let j = 0; j < 26; j++) {\n\t\t\t\tcurCol[String.fromCharCode(97 + j)] = MappingTable.possible;\n\t\t\t}\n\t\t}\n\t\tthis.mode = MappingTable.impossible;\n\t}\n\n\tdisallow(oriChar, matchedChar) {\n\t\tconst isChanged = this.matrix[oriChar][matchedChar] !== this.mode;\n\t\tthis.matrix[oriChar][matchedChar] = this.mode;\n\t\treturn isChanged;\n\t}\n\n\tunique(ch) {\n\t\tlet count = 0;\n\t\tfor (let i = 0; i < 26; i++) {\n\t\t\tif (this.matrix[ch][String.fromCharCode(97 + i)] === MappingTable.possible) {\n\t\t\t\tthis.ensure[ch] = String.fromCharCode(97 + i);\n\t\t\t\tcount++;\n\t\t\t\tif (count > 1) {\n\t\t\t\t\tthis.ensure[ch] = null;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tgetAllowedChars(oriChar) {\n\t\tconst ret = new Array();\n\t\tfor (let i = 0; i < 26; i++) {\n\t\t\tif (this.matrix[oriChar][String.fromCharCode(97 + j)] !== MappingTable.impossible) {\n\t\t\t\tret.push(String.fromCharCode(97 + j));\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tisAllowed(oriChar, matchedChar) {\n\t\treturn this.matrix[oriChar][matchedChar];\n\t}\n\n\tmapMode(mode) {\n\t\tthis.mode = mode;\n\t}\n\n\tcopy() {\n\t\tconst ret = new MappingTable();\n\t\tret.ensure = [].concat(this.ensure);\n\t\tfor (let i = 0; i < 26; i++) {\n\t\t\tfor (let j = 0; j < 26; j++) {\n\t\t\t\tret.matrix[String.fromCharCode(97 + i)][String.fromCharCode(97 + j)] = this.matrix[String.fromCharCode(97 + i)][String.fromCharCode(97 + j)];\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nMappingTable.guessPossible = 3;\nMappingTable.guessImpossible = 2;\nMappingTable.possible = 1;\nMappingTable.impossible = 0;\n\n//# sourceURL=webpack://Solver/./src/substitution/MappingTable.js?");

/***/ }),

/***/ "./src/substitution/Token.js":
/*!***********************************!*\
  !*** ./src/substitution/Token.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Token\": () => (/* binding */ Token)\n/* harmony export */ });\n/* harmony import */ var _MappingTable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MappingTable */ \"./src/substitution/MappingTable.js\");\n\n\nclass Token {\n\tconstructor(word, possibleList, position) {\n\t\tthis.word = word;\n\t\tthis.possibleList = JSON.parse(JSON.stringify(possibleList));\n\t\tthis.position = position;\n\t}\n\n\teliminate(mappingTable) {\n\t\tvar len = this.word.length,\n\t\t    possibleListLen = this.possibleList.length,\n\t\t    deleteList = new Array(),\n\t\t    flag = false;\n\t\t// For each possible word, delete it if it's letter is not matched.\n\t\tfor (var i = 0; i < possibleListLen; i++) {\n\t\t\tvar possibleWord = this.possibleList[i];\n\t\t\tif (possibleWord === undefined) {\n\t\t\t\tdeleteList[i] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (var j = 0; j < len; j++) {\n\t\t\t\tif (mappingTable.isAllowed(this.word[j], possibleWord[j]) === _MappingTable__WEBPACK_IMPORTED_MODULE_0__.MappingTable.impossible) {\n\t\t\t\t\tdeleteList[i] = 1;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (var i = possibleListLen - 1; i >= 0; i--) {\n\t\t\tif (deleteList[i] === 1) {\n\t\t\t\tthis.possibleList.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\treturn flag;\n\t}\n\ttrimMappingTable(mappingTable) {\n\t\tvar len = this.word.length,\n\t\t    possibleListLen = this.possibleList.length,\n\t\t    possibleLetters = new Array(26),\n\t\t    flag = false;\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tfor (var j = 0; j < 26; j++) {\n\t\t\t\tpossibleLetters[j] = _MappingTable__WEBPACK_IMPORTED_MODULE_0__.MappingTable.impossible;\n\t\t\t}\n\t\t\tvar curLetter = this.word[i];\n\t\t\tfor (var j = 0; j < possibleListLen; j++) {\n\t\t\t\tpossibleLetters[this.possibleList[j].charCodeAt(i) - 97] = _MappingTable__WEBPACK_IMPORTED_MODULE_0__.MappingTable.possible;\n\t\t\t}\n\t\t\tfor (var j = 0; j < 26; j++) {\n\t\t\t\tif (possibleLetters[j] !== _MappingTable__WEBPACK_IMPORTED_MODULE_0__.MappingTable.possible) {\n\t\t\t\t\tconst isChanged = mappingTable.disallow(this.word[i], String.fromCharCode(97 + j));\n\t\t\t\t\tflag = flag || isChanged;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (mappingTable.unique(curLetter) === true) {\n\t\t\t\tconst ensureLetter = mappingTable.ensure[curLetter];\n\t\t\t\tfor (var j = 0; j < 26; j++) {\n\t\t\t\t\tif (curLetter === String.fromCharCode(j + 97)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst isChanged = mappingTable.disallow(String.fromCharCode(97 + j), ensureLetter);\n\t\t\t\t\tflag = isChanged || flag;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn flag;\n\t}\n\tcustomize(mappingTable) {\n\t\tlet isEliminated = this.eliminate(mappingTable);\n\t\tlet isTrimed = this.trimMappingTable(mappingTable);\n\t\treturn isEliminated || isTrimed;\n\t}\n\tcopy() {\n\t\tvar ret = new Token(this.word, this.possibleList, this.position);\n\t\treturn ret;\n\t}\n}\n\n//# sourceURL=webpack://Solver/./src/substitution/Token.js?");

/***/ }),

/***/ "./src/substitution/substitution.js":
/*!******************************************!*\
  !*** ./src/substitution/substitution.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SubstitutionSolver\": () => (/* binding */ SubstitutionSolver)\n/* harmony export */ });\n/* harmony import */ var _MappingTable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MappingTable */ \"./src/substitution/MappingTable.js\");\n/* harmony import */ var _token_list_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./token-list.js */ \"./src/substitution/token-list.js\");\n\n\n\nclass SubstitutionSolver {\n\tconstructor() {\n\t\tthis.globleAns = [];\n\t\tthis.ans = new Array();\n\t\tthis.weight = [];\n\t\tthis.threshold = 10;\n\t}\n\tsubstituteSolver(text, maxOutput, threshold) {\n\t\tthis.threshold = threshold || 10;\n\t\tthis.maxOutput = maxOutput || 3000;\n\t\tvar text = text.toLowerCase();\n\t\tvar rawTokens = text.split(/[^a-zA-Z\\']+/);\n\t\tvar mappingTable = new _MappingTable__WEBPACK_IMPORTED_MODULE_0__.MappingTable();\n\t\tvar unknownWordsList = new _token_list_js__WEBPACK_IMPORTED_MODULE_1__.TokenList();\n\t\tthis.globleAns = [];\n\t\tthis.ans = [];\n\t\tvar knownWordsList = new _token_list_js__WEBPACK_IMPORTED_MODULE_1__.TokenList();\n\n\t\tunknownWordsList.build(rawTokens, knownWordsList, mappingTable, this.weight);\n\n\t\tunknownWordsList.refreshByMappintTable(knownWordsList, mappingTable);\n\n\t\tthis.dfsNonRecursion(unknownWordsList, knownWordsList, mappingTable);\n\t\t// this.dfs(unknownWordsList, knownWordsList, mappingTable);\n\n\t\tthis.globleAns.sort((a, b) => b.weight - a.weight);\n\t\tconsole.info(this.globleAns);\n\t\treturn this.globleAns.map(item => item.ret);\n\t}\n\n\toutput(answer) {\n\t\tlet ret = \"\";\n\t\tlet weight = 0;\n\t\tfor (let possibleToken of answer.list) {\n\t\t\tret += possibleToken.possibleList[0] + \" \";\n\t\t\tweight += this.weight[possibleToken.possibleList[0]];\n\t\t}\n\t\tthis.globleAns.push({ ret, weight });\n\t}\n\n\t/*\r\n  *\tpara:\r\n  *\t\tunknownWordsList - list of unknown words, unknown means it's possiable list is greater than one\r\n  *\t\tanswer - list of known words, known means the possible list of it is only one\r\n  *\t\tmappingTable - it's a 26*26 table which represents letter's mapping of ct & pt\r\n  *  return:\r\n  *  \tvoid\r\n */\n\n\tdfs(unknownWordsList, knownWordsList, mappingTable) {\n\t\tif (unknownWordsList.empty()) {\n\t\t\tthis.output(knownWordsList);\n\t\t\treturn;\n\t\t}\n\n\t\tconst minSizeIndex = unknownWordsList.getMinPossibleList();\n\t\tconst minLen = unknownWordsList.list[minSizeIndex].possibleList.length;\n\n\t\tfor (var i = 0; i < minLen; i++) {\n\t\t\tconst chooseWord = unknownWordsList.list[minSizeIndex].possibleList[i];\n\t\t\tconst dummyUnknownWordsList = unknownWordsList.copy();\n\t\t\tconst dummyAns = knownWordsList.copy();\n\t\t\tconst dummyMappingTable = mappingTable.copy();\n\n\t\t\tdummyUnknownWordsList.setPossibleList(minSizeIndex, chooseWord);\n\n\t\t\tif (dummyUnknownWordsList.refreshByMappintTable(dummyAns, dummyMappingTable) === false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis.dfs(dummyUnknownWordsList, dummyAns, dummyMappingTable);\n\t\t}\n\t}\n\n\tdfsNonRecursion(unknownWordsList, knownWordsList, mappingTable) {\n\t\tlet stack = new Array();\n\t\tstack.push({ unknownWordsList, knownWordsList, mappingTable });\n\t\tlet countOfAnswer = 0;\n\t\tlet stack2 = new Array();\n\t\twhile (stack.length > 0 || stack2.length > 0) {\n\t\t\twhile (stack.length > 0) {\n\t\t\t\tconst state = stack.pop();\n\t\t\t\tif (state.unknownWordsList.empty()) {\n\t\t\t\t\tthis.output(state.knownWordsList);\n\t\t\t\t\tcountOfAnswer++;\n\t\t\t\t\tif (countOfAnswer > this.maxOutput) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tconst minSizeIndex = state.unknownWordsList.getMinPossibleList();\n\t\t\t\tconst minLen = state.unknownWordsList.list[minSizeIndex].possibleList.length;\n\t\t\t\tconst loopLen = Math.min(minLen, this.threshold);\n\n\t\t\t\tfor (var i = 0; i < loopLen; i++) {\n\t\t\t\t\tconst chooseWord = state.unknownWordsList.list[minSizeIndex].possibleList[i];\n\t\t\t\t\tconst dummyUnknownWordsList = state.unknownWordsList.copy();\n\t\t\t\t\tconst dummyAns = state.knownWordsList.copy();\n\t\t\t\t\tconst dummyMappingTable = state.mappingTable.copy();\n\n\t\t\t\t\tdummyUnknownWordsList.setPossibleList(minSizeIndex, chooseWord);\n\n\t\t\t\t\tif (dummyUnknownWordsList.refreshByMappintTable(dummyAns, dummyMappingTable) === false) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tstack.push({ unknownWordsList: dummyUnknownWordsList, knownWordsList: dummyAns, mappingTable: dummyMappingTable });\n\t\t\t\t}\n\t\t\t\tstate.unknownWordsList.list[minSizeIndex].possibleList = state.unknownWordsList.list[minSizeIndex].possibleList.slice(loopLen);\n\t\t\t\tif (state.unknownWordsList.refreshByMappintTable(state.knownWordsList, state.mappingTable) === false) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstack2.push({\n\t\t\t\t\tunknownWordsList: state.unknownWordsList,\n\t\t\t\t\tknownWordsList: state.knownWordsList,\n\t\t\t\t\tmappingTable: state.mappingTable\n\t\t\t\t});\n\t\t\t}\n\t\t\tstack = stack2;\n\t\t\tstack2 = new Array();\n\t\t}\n\t}\n\n}\n\n//# sourceURL=webpack://Solver/./src/substitution/substitution.js?");

/***/ }),

/***/ "./src/substitution/token-list.js":
/*!****************************************!*\
  !*** ./src/substitution/token-list.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TokenList\": () => (/* binding */ TokenList)\n/* harmony export */ });\n/* harmony import */ var _Token__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Token */ \"./src/substitution/Token.js\");\n\n\nclass TokenList {\n\tconstructor() {\n\t\tthis._list = [];\n\t}\n\n\tpattern(str) {\n\t\tvar curLetter = 0;\n\t\tvar len = str.length;\n\t\tvar ret = \"\";\n\t\tvar usedLetter = new Array(26);\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tif (usedLetter[str[i]] == undefined) {\n\t\t\t\tusedLetter[str[i]] = String.fromCharCode(curLetter + 97);\n\t\t\t\tcurLetter++;\n\t\t\t}\n\t\t\tret += usedLetter[str[i]];\n\t\t}\n\t\treturn ret;\n\t}\n\n\tgenerateWeight(possibleList, weight) {\n\t\tconst possibleListLen = possibleList.length;\n\t\tif (possibleListLen > 10) {\n\t\t\tfor (let i = 0; i < possibleListLen; i++) {\n\t\t\t\tif (possibleListLen > 100 && i <= 10) {\n\t\t\t\t\tweight[possibleList[i]] = 17;\n\t\t\t\t} else if (i / possibleListLen < 0.4) {\n\t\t\t\t\tweight[possibleList[i]] = 15;\n\t\t\t\t} else if (i / possibleListLen < 0.6) {\n\t\t\t\t\tweight[possibleList[i]] = 8;\n\t\t\t\t} else if (i / possibleListLen < 0.9) {\n\t\t\t\t\tweight[possibleList[i]] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tweight[possibleList[i]] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < possibleListLen; i++) {\n\t\t\t\tweight[possibleList[i]] = possibleListLen - i;\n\t\t\t}\n\t\t}\n\t}\n\n\tbuild(rawTokens, knownWordsList, mappingTable, weight) {\n\t\tconst words = window.words;\n\t\tconst countOfTokens = rawTokens.length;\n\t\tfor (let i = 0; i < countOfTokens; i++) {\n\t\t\tif (rawTokens[i] == \"\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (rawTokens[i].includes(\"'\")) {\n\t\t\t\tconst token = rawTokens[i].split(\"'\");\n\t\t\t\tif (token[1] && token[1].length === 1) {\n\t\t\t\t\tconst curToken = new _Token__WEBPACK_IMPORTED_MODULE_0__.Token(token[1], [\"s\", \"t\", \"d\"], i);\n\t\t\t\t\tthis._list.push(curToken);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst possibleList = words[this.pattern(rawTokens[i])].slice(0);\n\n\t\t\t\tthis.generateWeight(possibleList, weight);\n\n\t\t\t\tconst curToken = new _Token__WEBPACK_IMPORTED_MODULE_0__.Token(rawTokens[i], possibleList, i);\n\t\t\t\tcurToken.customize(mappingTable);\n\t\t\t\tif (curToken.possibleList.length > 1) {\n\t\t\t\t\tthis._list.push(curToken);\n\t\t\t\t} else {\n\t\t\t\t\tknownWordsList.list[curToken.position] = curToken;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tset list(val) {\n\t\tthis._list = val;\n\t}\n\n\tget list() {\n\t\treturn this._list;\n\t}\n\n\tpush(token) {\n\t\tthis._list.push(token);\n\t}\n\n\tcopy() {\n\t\tconst retTokenList = new TokenList();\n\t\tfor (let i = 0; i < this._list.length; i++) {\n\t\t\tconst wordToken = this._list[i];\n\t\t\tif (!wordToken) continue;\n\t\t\tretTokenList.list[i] = wordToken.copy();\n\t\t}\n\t\treturn retTokenList;\n\t}\n\n\tgetMinPossibleList() {\n\t\tvar minLen = this._list[0].possibleList.length;\n\t\tvar minIndex = 0;\n\t\tfor (let i = 0; i < this._list.length; i++) {\n\t\t\tif (minLen > this._list[i].possibleList.length) {\n\t\t\t\tminLen = this._list[i].possibleList.length;\n\t\t\t\tminIndex = i;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\n\trefreshByMappintTable(knownWordsList, mappingTable) {\n\t\tvar loopTime = 0;\n\t\tconst list = this._list;\n\t\tlet lastChanged = 0;\n\t\twhile (list.length > 0) {\n\t\t\tvar topToken = list.shift();\n\t\t\tconst isChanged = topToken.customize(mappingTable);\n\t\t\tif (topToken.possibleList.length > 1) {\n\t\t\t\tlist.push(topToken);\n\t\t\t} else if (topToken.possibleList.length === 0) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tknownWordsList.list[topToken.position] = topToken;\n\t\t\t}\n\n\t\t\tloopTime++;\n\t\t\tif (loopTime - lastChanged > list.length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (isChanged) {\n\t\t\t\tlastChanged = loopTime;\n\t\t\t}\n\t\t\t// if(loopTime > 500)break;\n\t\t}\n\t\treturn true;\n\t}\n\n\trefreshByMappintTable2(knownWordsList, mappingTable) {\n\t\tlet list = this._list;\n\t\twhile (1) {\n\t\t\tlet isChangedThisTurn = false;\n\t\t\tlet newList = [];\n\t\t\tfor (let i = 0; i < list.length; i++) {\n\t\t\t\tvar topToken = list[i];\n\t\t\t\tconst isChanged = topToken.customize(mappingTable);\n\t\t\t\tisChangedThisTurn = isChanged || isChangedThisTurn;\n\t\t\t\tif (topToken.possibleList.length > 1) {\n\t\t\t\t\tnewList.push(topToken);\n\t\t\t\t} else if (topToken.possibleList.length === 0) {\n\t\t\t\t\tthis._list = list;\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tknownWordsList.list[topToken.position] = topToken;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist = newList;\n\t\t\tif (isChangedThisTurn === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis._list = list;\n\t\treturn true;\n\t}\n\n\tempty() {\n\t\treturn this._list.length === 0;\n\t}\n\n\tsetPossibleList(index, word) {\n\t\tthis._list[index].possibleList = [];\n\t\tthis._list[index].possibleList.push(word);\n\t}\n}\n\n//# sourceURL=webpack://Solver/./src/substitution/token-list.js?");

/***/ }),

/***/ "./src/sudoku/index.js":
/*!*****************************!*\
  !*** ./src/sudoku/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SudokuSolver\": () => (/* binding */ SudokuSolver)\n/* harmony export */ });\n/* harmony import */ var _solverParser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./solverParser */ \"./src/sudoku/solverParser.js\");\n/* harmony import */ var _common_Trie__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Trie */ \"./src/common/Trie.js\");\n// TODO: Need to be refacted, the code here is tooooo terrible\n\n\nclass SudokuSolver {\n  constructor() {\n    this.possibleArray = [];\n    this.connectedRules = [];\n    this.globalRules = [];\n    this.globalFinalRules = [];\n    this.weight = [];\n  }\n\n  handleLoop(restrictAreas, _rule) {\n    const areasSet = new Set(restrictAreas);\n    const globalRules = this.globalRules;\n    const n = this.n;\n    const m = this.m;\n    for (const area of restrictAreas) {\n      let possibles = [...this.possibleArray[area]];\n      const row = area / m;\n      const col = area % m;\n      const areas = [area];\n      if (row == 0 || !areasSet.has(area - m)) {\n        possibles = possibles.filter(x => !x.includes('U'));\n      } else {\n        areas.push(area - m);\n      }\n      if (col == 0 || !areasSet.has(area - 1)) {\n        possibles = possibles.filter(x => !x.includes('L'));\n      } else {\n        areas.push(area - 1);\n      }\n      if (row == n - 1 || !areasSet.has(area + m)) {\n        possibles = possibles.filter(x => !x.includes('B'));\n      } else {\n        areas.push(area + m);\n      }\n      if (col == m - 1 || !areasSet.has(area + 1)) {\n        possibles = possibles.filter(x => !x.includes('R'));\n      } else {\n        areas.push(area + 1);\n      }\n      this.possibleArray[area] = new Set(possibles);\n      const rule = {\n        restrictAreas: areas,\n        rules: {\n          loop: _rule.rules.loop\n        }\n      };\n      globalRules.push(rule);\n    }\n    _rule.rules.loop.areasSet = new Set(areasSet);\n  }\n\n  async tryProcess() {\n    const n = this.n;\n    const m = this.m;\n    for (let idx = 0; idx < n * m; idx++) {\n      const temp = this.possibleArray[idx];\n      if (temp.size <= 1) continue;\n      const items = [];\n      for (const item of temp) {\n        this.possibleArray[idx] = new Set([item]);\n        const origin = [];\n        const newRule = [];\n\n        let flag = false;\n        for (let i = 0; i < this.connectedRules[idx].length; i++) {\n          const result = this.relaxRule(this.globalRules[this.connectedRules[idx][i]], origin, this.connectedRules[idx][i], newRule);\n          this.resumePossible(origin, newRule);\n          if (result === -1) {\n            flag = true;\n            break;\n          }\n        }\n        if (flag === false) {\n          items.push(item);\n        }\n      }\n      this.possibleArray[idx] = new Set(items);\n    }\n    return this.relax();\n  }\n\n  async solve(rulesList, n, m, callback) {\n    this.n = n;\n    this.m = m;\n    this.callback = callback;\n    const possibleArray = this.possibleArray;\n    const connectedRules = this.connectedRules;\n    const globalRules = this.globalRules;\n    const globalFinalRules = this.globalFinalRules;\n\n    new _solverParser__WEBPACK_IMPORTED_MODULE_0__.SolverParser(rulesList, n, m, globalRules, globalFinalRules);\n\n    for (let i = 0; i < n * m; i++) {\n      possibleArray.push(undefined);\n      connectedRules.push([]);\n      this.weight.push(0);\n    }\n\n    globalRules.descriptionRules = [];\n    globalRules.groupRules = [];\n    const forceRule = [];\n    for (let i = 0; i < globalRules.length; i++) {\n      const rule = globalRules[i];\n      const { restrictAreas } = rule;\n      const letterSet = rule.rules ? rule.rules.set : undefined;\n      if (letterSet) {\n        globalRules.descriptionRules.push(i);\n        if (rule.rules.force) {\n          forceRule.push(i);\n          continue;\n        }\n        if (rule.rules.hashi) {\n          this.mergeSet(restrictAreas[0], letterSet);\n        } else for (let j = 0; j < restrictAreas.length; j++) {\n          this.mergeSet(restrictAreas[j], letterSet);\n        }\n        if (rule.rules.loop) {\n          this.handleLoop(restrictAreas, rule);\n          continue;\n        }\n        if (Object.keys(rule.rules).length == 1) continue;\n      }\n      globalRules.groupRules.push(i);\n      for (let j = 0; j < restrictAreas.length; j++) {\n        connectedRules[restrictAreas[j]].push(i);\n        this.weight[restrictAreas[j]]++;\n      }\n    }\n\n    for (let i = 0; i < globalFinalRules.length; i++) {\n      const rule = globalFinalRules[i];\n      const { restrictAreas } = rule;\n      if (rule.rules && rule.rules.largerThan) {\n        for (let j = 0; j < restrictAreas.length; j++) {\n          possibleArray[restrictAreas[j]] = this.largerSet(possibleArray[restrictAreas[j]], rule.rules.largerThan);\n        }\n      } else if (rule.rules && rule.rules.smallerThan) {\n        for (let j = 0; j < restrictAreas.length; j++) {\n          possibleArray[restrictAreas[j]] = this.smallSet(possibleArray[restrictAreas[j]], rule.rules.smallerThan);\n        }\n      }\n    }\n\n    for (const index of forceRule) {\n      const rule = globalRules[index];\n      const { restrictAreas } = rule;\n      for (let j = 0; j < restrictAreas.length; j++) {\n        this.possibleArray[restrictAreas[j]] = new Set(rule.rules.set);\n      }\n    }\n    this.hasLoop = false;\n    let ret = this.relax();\n    if (ret != -1 && this.hasLoop) {\n      ret = await this.tryProcess();\n    }\n    $('#sudokuAnswer').html(\"\");\n    if (ret != -1) await this.dfs();\n\n    $('#sudokuAnswer').append(\"已找到所有解\");\n  }\n\n  relaxDifference(areas, origin, ruleSet) {\n    let fixed = [];\n    const mp = new Map();\n    for (let i = 0; i < areas.length; i++) {\n      const possibleList = [...this.possibleArray[areas[i]]];\n      for (let j = 0; j < possibleList.length; j++) {\n        const temp = mp.get(possibleList[j]);\n        if (temp) {\n          mp.set(possibleList[j], temp + 1);\n        } else {\n          mp.set(possibleList[j], 1);\n        }\n      }\n    }\n    mp.forEach((val, key) => {\n      if (val === 1) {\n        for (let i = 0; i < areas.length; i++) {\n          const area = areas[i];\n          const curPossibleArray = this.possibleArray[area];\n          if (curPossibleArray.size > 1 && curPossibleArray.has(key)) {\n            if (!origin[area]) {\n              origin[area] = new Set(curPossibleArray);\n            }\n            this.possibleArray[area] = new Set([key]);\n            for (const connectedRule of this.connectedRules[area]) {\n              ruleSet.add(connectedRule);\n            }\n          }\n        }\n      }\n    });\n\n    for (let i = 0; i < areas.length; i++) {\n      if (this.possibleArray[areas[i]].size === 1) {\n        const number = this.possibleArray[areas[i]].values().next().value;\n        if (fixed.includes(number)) {\n          return -1;\n        }\n        fixed.push(number);\n      }\n    }\n\n    for (let j = 0; j < fixed.length; j++) {\n      for (let i = 0; i < areas.length; i++) {\n        const possibleList = this.possibleArray[areas[i]];\n        if (possibleList.size > 1 && possibleList.has(fixed[j])) {\n          if (!origin[areas[i]]) {\n            origin[areas[i]] = new Set(possibleList);\n          }\n          possibleList.delete(fixed[j]);\n          if (possibleList.size === 0) {\n            console.info(\"No\");\n            return -1;\n          }\n          for (const connectedRule of this.connectedRules[areas[i]]) {\n            ruleSet.add(connectedRule);\n          }\n          if (possibleList.size === 1) {\n            fixed.push(possibleList.values().next().value);\n          }\n        }\n      }\n    }\n    fixed = [];\n    for (let i = 0; i < areas.length; i++) {\n      if (this.possibleArray[areas[i]].size === 1) {\n        const number = this.possibleArray[areas[i]].values().next().value;\n        if (fixed.includes(number)) {\n          return -1;\n        }\n        fixed.push(number);\n      }\n    }\n    return 1;\n  }\n\n  relaxSum(areas, origin, ruleSet, rule) {\n    const sum = rule.rules.sum;\n\n    let currentSum = undefined;\n    let currentSum2 = 0;\n    let fixedCount = areas.length;\n    let unknowList = 0;\n    let upperBound = 0;\n    let lowerBound = 0;\n    const maxValues = [];\n    const minValues = [];\n    for (let i = 0; i < areas.length; i++) {\n      const possibleList = [...this.possibleArray[areas[i]]];\n      if (possibleList.length === 0) {\n        return -1;\n      }\n      let currentMax = possibleList[0];\n      let currentMin = possibleList[0];\n      for (const element of possibleList) {\n        if (element > currentMax) {\n          currentMax = element;\n        }\n        if (element < currentMin) {\n          currentMin = element;\n        }\n      }\n      maxValues[i] = currentMax;\n      minValues[i] = currentMin;\n      upperBound += currentMax;\n      lowerBound += currentMin;\n      if (possibleList.length > 1) {\n        unknowList = areas[i];\n        currentSum = undefined;\n        continue;\n      }\n      currentSum = currentSum ? currentSum + possibleList[0] : possibleList[0];\n      fixedCount--;\n      currentSum2 += possibleList[0];\n    }\n    for (let i = 0; i < areas.length; i++) {\n      const possibleList = this.possibleArray[areas[i]];\n      const deleteItem = [];\n      for (const element of possibleList) {\n        if (upperBound + element - maxValues[i] < sum || lowerBound + element - minValues[i] > sum) {\n          deleteItem.push(element);\n        }\n      }\n      if (currentSum !== undefined && currentSum !== sum) {\n        return -1;\n      }\n      if (upperBound < sum || lowerBound > sum) {\n        return -1;\n      }\n      if (deleteItem.length > 0) {\n        if (!origin[areas[i]]) {\n          origin[areas[i]] = new Set(possibleList);\n        }\n        for (const connectedRule of this.connectedRules[areas[i]]) {\n          ruleSet.add(connectedRule);\n        }\n        for (const element of deleteItem) {\n          possibleList.delete(element);\n        }\n      }\n    }\n    if (fixedCount === 1) {\n      if (this.possibleArray[unknowList].has(sum - currentSum2)) {\n        if (!origin[unknowList]) {\n          origin[unknowList] = new Set(possibleList);\n        }\n        for (const connectedRule of this.connectedRules[unknowList]) {\n          ruleSet.add(connectedRule);\n        }\n        this.possibleArray[unknowList] = new Set([sum - currentSum2]);\n      } else {\n        return -1;\n      }\n    }\n    return 1;\n  }\n\n  relaxCount(areas, origin, rule, ruleSet) {\n    let cnt = 0;\n    let isFixed = true;\n    let hasItemCount = 0;\n    for (let i = 0; i < areas.length; i++) {\n      const list = this.possibleArray[areas[i]];\n      if (list.size <= 0) return -1;\n      if (list.has(rule.item)) {\n        hasItemCount++;\n      }\n      if (list.size === 1) {\n        if (list.values().next().value === rule.item) {\n          cnt++;\n        }\n      } else {\n        isFixed = false;\n      }\n    }\n    if (rule.set) {\n      const u = rule.set[0];\n      if (hasItemCount < u) {\n        return -1;\n      }\n      if (isFixed && cnt !== u) {\n        return -1;\n      }\n      if (!isFixed && hasItemCount === u) {\n        for (let i = 0; i < areas.length; i++) {\n          const possibleList = this.possibleArray[areas[i]];\n          if (possibleList.size > 1 && possibleList.has(rule.item)) {\n            if (!origin[areas[i]]) {\n              origin[areas[i]] = this.possibleArray[areas[i]];\n            }\n            for (const connectedRule of this.connectedRules[areas[i]]) {\n              ruleSet.add(connectedRule);\n            }\n            this.possibleArray[areas[i]] = new Set([rule.item]);\n          }\n        }\n      } else if (!isFixed && cnt === u) {\n        for (let i = 0; i < areas.length; i++) {\n          const possibleList = this.possibleArray[areas[i]];\n          if (possibleList.length > 1 && possibleList.has(rule.item)) {\n            if (!origin[areas[i]]) {\n              origin[areas[i]] = new Set(possibleList);\n            }\n            possibleList.delete(rule.item);\n            for (const connectedRule of this.connectedRules[areas[i]]) {\n              ruleSet.add(connectedRule);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  relaxLinear(rule, areas, origin, ruleSet) {\n    let currentResult = 0;\n    let upperBound = 0;\n    let lowerBound = 0;\n    let fixedCount = areas.length;\n\n    const maxValues = [];\n    const minValues = [];\n    for (let i = 0; i < areas.length; i++) {\n      const list = this.possibleArray[areas[i]];\n      if (list.size <= 0) return -1;\n      if (list.size > 1) {\n        return;\n      }\n\n      const number = list.values().next().value;\n      currentResult += number * rule.coefficient[i];\n    }\n    if (currentResult !== rule.result) {\n      return -1;\n    }\n\n    for (let i = 0; i < areas.length; i++) {\n      const possibleList = [...this.possibleArray[areas[i]]];\n      if (possibleList.length === 0) {\n        return -1;\n      }\n      let currentMax = possibleList[0];\n      let currentMin = possibleList[0];\n      for (const element of possibleList) {\n        const temp = element * rule.coefficient[i];\n        if (temp > currentMax) {\n          currentMax = temp;\n        }\n        if (temp < currentMin) {\n          currentMin = temp;\n        }\n      }\n      maxValues[i] = currentMax;\n      minValues[i] = currentMin;\n      upperBound += currentMax;\n      lowerBound += currentMin;\n      fixedCount--;\n    }\n    if (upperBound < rule.result || lowerBound > rule.result) {\n      return -1;\n    }\n  }\n\n  /*\r\n    -1: unknown\r\n    0: unsatisfied\r\n    1: satisfied\r\n  */\n  isSatisfied(areas, rule) {\n    const numbers = [];\n    for (const area of areas) {\n      if (this.possibleArray[area].size !== 1) return -1;\n      numbers.push(this.possibleArray[area].values().next().value);\n    }\n    if (rule.set) {\n      for (const number of numbers) {\n        if (!rule.set.includes(number)) {\n          return 0;\n        }\n      }\n    } else if (rule.largerThan) {\n      for (const number of numbers) {\n        if (number <= rule.largerThan) {\n          return 0;\n        }\n      }\n    } else if (rule.smallerThan) {\n      for (const number of numbers) {\n        if (number >= rule.smallerThan) {\n          return 0;\n        }\n      }\n    } else if (rule.sum) {\n      let currentSum = 0;\n      for (const number of numbers) {\n        currentSum += number;\n      }\n      if (currentSum !== rule.sum) return 0;\n    }\n    return 1;\n  }\n\n  relaxIfCondition(rule, areas, origin, ruleSet, newRule) {\n    if (this.isSatisfied(areas, rule.condition) === 1) {\n      for (const statement of rule.statement) {\n        const result = this.isSatisfied(statement.restrictAreas, statement.rules);\n        if (result === 0) {\n          return -1;\n        } else if (result === -1) {\n          if (statement.rules.sum) {\n            this.globalRules.push(statement);\n            const ruleIndex = this.globalRules.length - 1;\n            newRule[ruleIndex] = [];\n            for (const area of statement.restrictAreas) {\n              this.connectedRules[area].push(ruleIndex);\n              newRule[ruleIndex].push(area);\n            }\n          }\n          for (const area of statement.restrictAreas) {\n            if (this.possibleArray[area].size === 1) continue;\n            if (!origin[area]) {\n              origin[area] = new Set(this.possibleArray[area]);\n            }\n            for (const connectedRule of this.connectedRules[area]) {\n              ruleSet.add(connectedRule);\n            }\n\n            if (statement.rules.set) {\n              this.possibleArray[area] = new Set(statement.rules.set);\n            } else if (statement.rules.largerThan) {\n              this.possibleArray[area] = this.largerSet(this.possibleArray[area], statement.rules.largerThan);\n            } else if (statement.rules.smallerThan) {\n              this.possibleArray[area] = this.smallSet(this.possibleArray[area], statement.rules.smallerThan);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  relaxWord(areas, origin, ruleSet) {\n    const possibleList = [];\n    for (const area of areas) {\n      possibleList.push(this.possibleArray[area]);\n    }\n    const words = window.Trie.findAllByPossibleSets(possibleList);\n    console.info(words);\n    if (words.length >= 1000) return;\n    for (let i = 0; i < areas.length; i++) {\n      const letters = new Set();\n      for (const word of words) {\n        letters.add(word[i]);\n      }\n      const s = new Set([...letters].filter(item => possibleList[i].has(item)));\n      if (s.size === this.possibleArray[areas[i]].size) {\n        continue;\n      }\n      if (!origin[areas[i]]) {\n        origin[areas[i]] = new Set(this.possibleArray[areas[i]]);\n      }\n      for (const connectedRule of this.connectedRules[areas[i]]) {\n        ruleSet.add(connectedRule);\n      }\n\n      this.possibleArray[areas[i]] = new Set([...letters].filter(item => possibleList[i].has(item)));\n    }\n  }\n\n  relaxBars(areas, origin, ruleSet, rule) {\n    console.info(areas, origin, ruleSet, rule);\n    // dp1[i][j]: i's grid j's number, last grid is black\n    // dp2[i][j]: i's grid j's number, last grid is white\n    // dp1[i][j] = dp2[i-number[j]][j-1] & all j to i is black\n    // dp2[i][j] = dp2[i-1][j] | dp1[i-1][j]\n    const sum = [0];\n    const n = areas.length;\n    const m = rule.list.length;\n    let last = 0;\n    const white = [];\n    const black = [];\n    const border = [];\n    const mustBlack = [];\n    for (let i = 0; i <= n; i++) {\n      white.push(false);\n      black.push(false);\n      mustBlack.push(false);\n    }\n\n    for (let i = 0; i < areas.length; i++) {\n      const area = areas[i];\n      if (this.possibleArray[area].has(rule.item)) {\n        last++;\n        if (this.possibleArray[area].size === 1) {\n          mustBlack[i + 1] = true;\n        }\n      }\n      sum.push(last);\n    }\n    const dp1 = [[]];\n    const dp2 = [[]];\n    for (let i = 0; i <= m; i++) {\n      dp1[0].push(false);\n      dp2[0].push(false);\n    }\n    dp2[0][0] = true;\n    for (let i = 0; i <= m; i++) {\n      border.push(n + 2);\n    }\n    for (let i = 1; i <= n; i++) {\n      dp1.push([false]);\n      if (mustBlack[i]) dp2.push([false]);else dp2.push([dp2[i - 1][0]]);\n      for (let j = 1; j <= m; j++) {\n        let canBeFill = false;\n        if (i - rule.list[j - 1] >= 0 && sum[i] - sum[i - rule.list[j - 1]] === rule.list[j - 1]) {\n          canBeFill = true;\n        }\n        if (canBeFill) {\n          if (i != n && mustBlack[i + 1] === true) {\n            dp1[i].push(false);\n          } else dp1[i].push(dp2[i - rule.list[j - 1]][j - 1]);\n        } else dp1[i].push(false);\n        if (mustBlack[i]) dp2[i].push(false);else dp2[i].push(dp2[i - 1][j] || dp1[i - 1][j]);\n      }\n    }\n\n    for (let i = m; i >= 1; i--) {\n      for (let j = border[i] - 2; j >= 1; j--) {\n        if (dp1[j][i]) {\n          border[i - 1] = j - rule.list[i - 1] + 1;\n          break;\n        }\n      }\n    }\n\n    for (let i = n; i >= 1; i--) {\n      if (i < border[0] && mustBlack[i] === false) {\n        white[i] = true;\n      }\n      for (let j = m; j >= 1; j--) {\n        if (dp1[i][j] && i < border[j] - 1) {\n          for (let k = i; k >= i - rule.list[j - 1] + 1; k--) {\n            black[k] = true;\n          }\n        }\n        if (dp2[i][j] && i < border[j] && mustBlack[i] === false) {\n          white[i] = true;\n        }\n      }\n    }\n\n    for (let i = 1; i <= n; i++) {\n      const list = this.possibleArray[areas[i - 1]];\n      if (black[i] && !white[i]) {\n        if (!list.has(rule.item)) {\n          return -1;\n        }\n      }\n      if (!black[i] && white[i]) {\n        if (list.has(rule.item) && list.size === 1) {\n          return -1;\n        }\n      }\n      if (!black[i] && !white[i]) {\n        return -1;\n      }\n      if (!black[i] && mustBlack[i]) {\n        return -1;\n      }\n    }\n\n    for (let i = 1; i <= n; i++) {\n      if (black[i] && !white[i] && this.possibleArray[areas[i - 1]].size > 1) {\n        if (!origin[areas[i - 1]]) {\n          origin[areas[i - 1]] = new Set(this.possibleArray[areas[i - 1]]);\n        }\n        for (const connectedRule of this.connectedRules[areas[i - 1]]) {\n          ruleSet.add(connectedRule);\n        }\n        this.possibleArray[areas[i - 1]] = new Set([rule.item]);;\n      }\n      if (!black[i] && white[i] && this.possibleArray[areas[i - 1]].has(rule.item)) {\n        if (!origin[areas[i - 1]]) {\n          origin[areas[i - 1]] = new Set(this.possibleArray[areas[i - 1]]);\n        }\n        for (const connectedRule of this.connectedRules[areas[i - 1]]) {\n          ruleSet.add(connectedRule);\n        }\n        this.possibleArray[areas[i - 1]].delete(rule.item);\n      }\n    }\n  }\n\n  relaxPermutation(areas, origin, ruleSet, rule) {\n    const list = Array.from(rule.list);\n    const n = areas.length;\n    const realAreas = [];\n    const alreadyHave = [];\n\n    for (const area of areas) {\n      if (this.possibleArray[area].size === 1) {\n        const value = this.possibleArray[area].values().next().value;\n        if (value === 'black') {\n          continue;\n        }\n        alreadyHave.push(value);\n      } else {\n        realAreas.push(area);\n      }\n    }\n    for (const item of alreadyHave) {\n      let flag = false;\n      for (let i = 0; i < list.length; i++) {\n        if (item === list[i]) {\n          list.splice(i, 1);\n          flag = true;\n          break;\n        }\n      }\n      if (!flag) return -1;\n    }\n\n    const impossible = [];\n    for (const item of alreadyHave) {\n      let flag = false;\n      for (let i = 0; i < list.length; i++) {\n        if (item === list[i]) {\n          flag = true;\n          break;\n        }\n      }\n      if (!flag) impossible.push(item);\n    }\n    for (const area of realAreas) {\n      for (const item of impossible) {\n        if (!this.possibleArray[area].has(item)) continue;\n\n        if (!origin[area]) {\n          origin[area] = new Set(this.possibleArray[area]);\n        }\n        for (const connectedRule of this.connectedRules[area]) {\n          ruleSet.add(connectedRule);\n        }\n        this.possibleArray[area];\n      }\n    }\n  }\n\n  relaxLoop(areas, origin, rule, ruleSet) {\n    const opp = { 'U': 'B', 'L': 'R', 'R': 'L', 'B': 'U' };\n    const dirIdx = { 'U': 0, 'B': 1, 'L': 2, 'R': 3 };\n    const dirs = ['U', 'B', 'L', 'R'];\n    const dirsOps = [-this.m, this.m, -1, 1];\n    const cur = areas[0];\n    let curPossibles = [...this.possibleArray[cur]];\n    const count = {};\n    for (const item of curPossibles) {\n      if (item.length != 2) continue;\n      count[item[0]] = (count[item[0]] || 0) + 1;\n      count[item[1]] = (count[item[1]] || 0) + 1;\n    }\n    const lastLen = curPossibles.length;\n\n    const isLoop = (start, end, dir) => {\n      let cur = start;\n      let lastDir = dir;\n      let count = 0;\n      while (1) {\n        if (cur == end) return count + 1;\n        if (!cur || this.possibleArray[cur].size != 1) return;\n        const d = this.possibleArray[cur].values().next().value.replace(lastDir, '');\n        cur = cur + dirsOps[dirIdx[d]];\n        lastDir = opp[d];\n        count++;\n      }\n    };\n\n    let dummyCurPossibles = [];\n    let dummyCurPossibles2 = [];\n\n    for (let i = 0; i < 4; i++) {\n      const dir = dirs[i];\n      const dirOp = dirsOps[i];\n      const area = cur + dirOp;\n\n      if (areas.indexOf(cur + dirOp) == -1) continue;\n      const oppDir = opp[dir];\n      let neighbour = [...this.possibleArray[area]];\n      if (!count[dir]) {\n        if (neighbour.filter(x => !x.includes(oppDir)).length <= 0) {\n          return -1;\n        }\n\n        neighbour = neighbour.filter(x => !x.includes(oppDir));\n        if (this.possibleArray[area].size != neighbour.length) {\n          if (!origin[area]) {\n            origin[area] = new Set(this.possibleArray[area]);\n          }\n          for (const connectedRule of this.connectedRules[area]) {\n            ruleSet.add(connectedRule);\n          }\n          this.possibleArray[area] = new Set(neighbour);\n        }\n      } else if (count[dir] === curPossibles.length) {\n        if (neighbour.filter(x => x.includes(oppDir)).length <= 0) {\n          return -1;\n        }\n\n        neighbour = neighbour.filter(x => x.includes(oppDir));\n        if (this.possibleArray[area].size != neighbour.length) {\n          if (!origin[area]) {\n            origin[area] = new Set(this.possibleArray[area]);\n          }\n          for (const connectedRule of this.connectedRules[area]) {\n            ruleSet.add(connectedRule);\n          }\n          this.possibleArray[area] = new Set(neighbour);\n        }\n      } else {\n        if (neighbour.filter(x => x.includes(oppDir)).length <= 0) {\n          dummyCurPossibles.push(dir);\n        }\n        if (neighbour.filter(x => !x.includes(oppDir)).length == 0) {\n          dummyCurPossibles2.push(dir);\n        }\n      }\n    }\n\n    for (const dir of dummyCurPossibles) {\n      curPossibles = curPossibles.filter(x => !x.includes(dir));\n    }\n    for (const dir of dummyCurPossibles2) {\n      curPossibles = curPossibles.filter(x => x.includes(dir));\n    }\n\n    if (rule.number == 1) for (let i = 0; i < curPossibles.length; i++) {\n      const possible = curPossibles[i];\n      if (possible == 'UR' || possible == 'UL') {\n        continue;\n      }\n      const diri = cur + dirsOps[dirIdx[possible[0]]],\n            dirj = cur + dirsOps[dirIdx[possible[1]]];\n      const x = [...this.possibleArray[diri]].filter(x => x.includes(opp[possible[0]]));\n      const y = [...this.possibleArray[dirj]].filter(x => x.includes(opp[possible[1]]));\n      if (x.length != 1 || y.length != 1) continue;\n      const originx = this.possibleArray[diri];\n      this.possibleArray[diri] = new Set(x);\n      const loopLen = isLoop(diri, dirj, opp[possible[0]]);\n      if (loopLen && loopLen + 1 != rule.areasSet.size) {\n        curPossibles[i] = '';\n      }\n      this.possibleArray[diri] = originx;\n    }\n    curPossibles = curPossibles.filter(x => x != '');\n\n    if (lastLen > curPossibles.length) {\n      if (!origin[cur]) {\n        origin[cur] = new Set(this.possibleArray[cur]);\n      }\n      for (const connectedRule of this.connectedRules[cur]) {\n        ruleSet.add(connectedRule);\n      }\n      this.possibleArray[cur] = new Set(curPossibles);\n    }\n  }\n\n  relaxHashi(areas, origin, rule, ruleSet) {\n    const dirs = ['u', 'd', 'l', 'r'];\n    const oppDir = { 'u': 'd', 'd': 'u', 'l': 'r', 'r': 'l' };\n    const to = rule.to;\n    const possibles = this.possibleArray[areas[0]];\n    const getIntersection = (setA, setB) => new Set(setB.filter(element => setA.includes(element)));\n    const getSet = (set, dir) => {\n      const ret = [];\n      for (const item of set) {\n        ret.push(item.hashi[dir]);\n      }\n      return ret;\n    };\n    for (const dir of dirs) {\n      const neighbour = to[dir];\n      if (!neighbour) continue;\n      const neighbourPossible = [...this.possibleArray[neighbour]];\n      const opp = oppDir[dir];\n      const inter = getIntersection(getSet(possibles, dir), getSet(neighbourPossible, opp));\n      for (const item of possibles) {\n        if (!inter.has(item.hashi[dir])) {\n          if (!origin[areas[0]]) {\n            origin[areas[0]] = new Set(this.possibleArray[areas[0]]);\n          }\n          for (const connectedRule of this.connectedRules[areas[0]]) {\n            ruleSet.add(connectedRule);\n          }\n          this.possibleArray[areas[0]].delete(item);\n        }\n      }\n      for (const item of neighbourPossible) {\n        if (!inter.has(item.hashi[opp])) {\n          if (!origin[neighbour]) {\n            origin[neighbour] = new Set(this.possibleArray[neighbour]);\n          }\n          for (const connectedRule of this.connectedRules[neighbour]) {\n            ruleSet.add(connectedRule);\n          }\n          this.possibleArray[neighbour].delete(item);\n        }\n      }\n    }\n    if (rule.conflict) {\n      if (rule.conflict.d) {\n        const d = rule.conflict.d.rules;\n        let flag = false;\n        if (d) for (const cflct of d) {\n          const area = [...this.possibleArray[cflct.to.self]].filter(x => !x.hashi.r);\n          if (area.length === 0) {\n            flag = true;\n            break;\n          }\n        }\n        if (flag) {\n          const newPossible = [...this.possibleArray[areas[0]]].filter(x => !x.hashi.d);\n          if (newPossible.length === 0) return -1;\n          if (newPossible.length < this.possibleArray[areas[0]].size) {\n            if (!origin[areas[0]]) {\n              origin[areas[0]] = new Set(this.possibleArray[areas[0]]);\n            }\n            this.possibleArray[areas[0]] = new Set(newPossible);\n          }\n        }\n      }\n\n      if (rule.conflict.r) {\n        const r = rule.conflict.r.rules;\n        let flag = false;\n        if (r) for (const cflct of r) {\n          const area = [...this.possibleArray[cflct.to.self]].filter(x => !x.hashi.d);\n          if (area.length === 0) {\n            flag = true;\n            break;\n          }\n        }\n        if (flag) {\n          const newPossible = [...this.possibleArray[areas[0]]].filter(x => !x.hashi.r);\n          if (newPossible.length === 0) return -1;\n          if (newPossible.length < this.possibleArray[areas[0]].size) {\n            if (!origin[areas[0]]) {\n              origin[areas[0]] = new Set(this.possibleArray[areas[0]]);\n            }\n            this.possibleArray[areas[0]] = new Set(newPossible);\n          }\n        }\n      }\n    }\n  }\n\n  relaxRule(rule, origin, index, newRule) {\n    const ruleSet = new Set([]);\n    const areas = rule.restrictAreas;\n    if (rule.rules.isDifferent) {\n      const ret = this.relaxDifference(areas, origin, ruleSet);\n      if (ret === -1) return -1;\n    } else if (rule.rules.sum) {\n      const ret = this.relaxSum(areas, origin, ruleSet, rule);\n      if (ret === -1) return -1;\n    } else if (rule.rules.count) {\n      const ret = this.relaxCount(areas, origin, rule.rules.count, ruleSet);\n      if (ret === -1) return -1;\n    } else if (rule.rules.linear) {\n      const ret = this.relaxLinear(rule.rules.linear, areas, origin, ruleSet);\n      if (ret === -1) return -1;\n    } else if (rule.rules.ifCondition) {\n      const ret = this.relaxIfCondition(rule.rules.ifCondition, areas, origin, ruleSet, newRule);\n      if (ret === -1) return -1;\n    } else if (rule.rules.isWord) {\n      const ret = this.relaxWord(areas, origin, ruleSet);\n      if (ret === -1) return -1;\n    } else if (rule.rules.bars) {\n      const ret = this.relaxBars(areas, origin, ruleSet, rule.rules.bars);\n      if (ret === -1) return -1;\n    } else if (rule.rules.permutation) {\n      const ret = this.relaxPermutation(areas, origin, ruleSet, rule.rules.permutation);\n      if (ret === -1) return -1;\n    } else if (rule.rules.loop) {\n      const ret = this.relaxLoop(areas, origin, rule.rules.loop, ruleSet);\n      if (ret === -1) return -1;\n      this.hasLoop = true;\n    } else if (rule.rules.hashi) {\n      const ret = this.relaxHashi(areas, origin, rule.rules.hashi, ruleSet);\n      if (ret === -1) return -1;\n    }\n\n    for (const rules of ruleSet) {\n      if (index === rules) continue;\n      const result = this.relaxRule(this.globalRules[rules], origin, rules, newRule);\n      if (result === -1) return -1;\n    }\n    return 1;\n  }\n\n  print() {\n    const result = [];\n    let answer = \"\";\n    let temp = [];\n    $(\"#showcase .vertical-\").remove();\n    $(\"#showcase .horizon-\").remove();\n    let isObject = false;\n    for (let i = 0; i < this.possibleArray.length; i++) {\n      const possibleArray = this.possibleArray[i];\n      if (!possibleArray || possibleArray.size != 1) continue;\n      const number = possibleArray ? possibleArray.values().next().value : ' ';\n      if (number.hashi) {\n        isObject = true;\n        const r = number.to['r'];\n        const rnum = number.hashi['r'];\n        const d = number.to['d'];\n        const dnum = number.hashi['d'];\n        if (rnum) {\n          let cur = i + 1;\n          $(`#showcase .sudoku-grid #grid-${cur}`).html(\"\");\n          const interval = 100 / (rnum + 1);\n          while (cur != r) {\n            for (let i = 0; i < rnum; i++) {\n              $(`#showcase .sudoku-grid #grid-${cur}`).append(`<div class=\"horizon-\" style=\"top:${interval * (i + 1)}%\"></div>`);\n            }\n            cur++;\n          }\n        }\n        if (dnum) {\n          let cur = i + this.m;\n          $(`#showcase .sudoku-grid #grid-${cur}`).html(\"\");\n          const interval = 100 / (dnum + 1);\n          while (cur != d) {\n            for (let i = 0; i < dnum; i++) {\n              $(`#showcase .sudoku-grid #grid-${cur}`).append(`<div class=\"vertical-\" style=\"left:${interval * (i + 1)}%\"></div>`);\n            }\n            cur += this.m;\n          }\n        }\n      } else if (number === 'black') {\n        $(`#showcase .sudoku-grid #grid-${i}`).css(\"background-color\", number);\n        $(`#showcase .sudoku-grid #grid-${i}`).css(\"color\", \"white\");\n        isObject = true;\n      } else if (number === 'white') {\n        $(`#showcase .sudoku-grid #grid-${i}`).css(\"background-color\", number);\n        $(`#showcase .sudoku-grid #grid-${i}`).css(\"color\", \"black\");\n        isObject = true;\n      } else if (number.length == 2) {\n        isObject = true;\n        $(`#showcase .sudoku-grid #grid-${i}`).attr(\"class\", \"sudoku-grid-content \" + number);\n        $(`#showcase .sudoku-grid #grid-${i}`).css(\"color\", \"white\");\n      } else {\n        $(`#showcase .sudoku-grid #grid-${i}`).css(\"background-color\", number);\n      }\n      temp.push(number);\n      answer += number + ' ';\n      if (i % this.m === this.m - 1) {\n        result.push(temp);\n        answer += '\\n';\n        temp = [];\n      }\n    }\n    if (isObject) {\n      const ans = $('#showcase #sudokuContainer').clone();\n      $('#sudokuAnswer').append(ans);\n      for (let i = 0; i < this.possibleArray.length; i++) {\n        const possibleArray = this.possibleArray[i];\n        if (!possibleArray || possibleArray.size != 1) continue;\n        const number = possibleArray ? possibleArray.values().next().value : ' ';\n        if (number.hashi) continue;\n        if (number.length === 2) continue;\n        if (number == \"black\" || number == \"white\" || number == \"red\") continue;\n        ans.find(`.sudoku-grid #grid-${i}`).html(number.toString());\n      }\n    } else $('#sudokuAnswer').append(answer + \"\\n-----------------------\\n\");\n  }\n\n  relax() {\n    for (let i = 0; i < this.globalRules.groupRules.length; i++) {\n      const rule = this.globalRules[this.globalRules.groupRules[i]];\n      const ret = this.relaxRule(rule, [], this.globalRules.groupRules[i], []);\n      if (ret == -1) return ret;\n    }\n  }\n\n  mergeSet(pos, set) {\n    const getIntersection = (setA, setB) => new Set(setB.filter(element => setA.has(element)));\n    if (this.possibleArray[pos] === undefined) {\n      this.possibleArray[pos] = new Set(set);\n    } else {\n      this.possibleArray[pos] = getIntersection(this.possibleArray[pos], set);\n    }\n  }\n\n  getSmallestGrid() {\n    let smallestGridIndex = -1;\n    let smallestGridSize = 1024;\n    let largestW = 0;\n    for (let i = 0; i < this.possibleArray.length; i++) {\n      const currentSetSize = this.possibleArray[i] ? this.possibleArray[i].size : 1;\n      const w = this.weight[i];\n      if (currentSetSize === 1) continue;\n      if (currentSetSize < smallestGridSize || currentSetSize == smallestGridSize && w > largestW) {\n        largestW = w;\n        smallestGridSize = currentSetSize;\n        smallestGridIndex = i;\n      }\n      if (smallestGridSize === 2 && w != 0) {\n        return smallestGridIndex;\n      }\n    }\n    return smallestGridIndex;\n  }\n\n  async dfs() {\n    const smallestGridIndex = this.getSmallestGrid();\n    if (smallestGridIndex === -1) {\n      this.print();\n      await this.callback();\n      if (confirm('发现了一个解，是否继续寻找下一个解?(可能耗时很久)')) {\n        return 0;\n      } else {\n        return -1;\n      }\n    }\n    const set = this.possibleArray[smallestGridIndex];\n\n    for (const item of set.values()) {\n      const origin = [];\n      const newRule = [];\n      origin[smallestGridIndex] = new Set(this.possibleArray[smallestGridIndex]);\n      this.possibleArray[smallestGridIndex] = new Set([item]);\n      if (this.connectedRules[smallestGridIndex]) {\n        let flag = false;\n        for (let i = 0; i < this.connectedRules[smallestGridIndex].length; i++) {\n          const result = this.relaxRule(this.globalRules[this.connectedRules[smallestGridIndex][i]], origin, this.connectedRules[smallestGridIndex][i], newRule);\n          if (result === -1) {\n            this.resumePossible(origin, newRule);\n            flag = true;\n            break;\n          }\n        }\n        if (flag === true) {\n          continue;\n        }\n      }\n\n      const result = await this.dfs();\n      if (result === -1) {\n        return result;\n      }\n      this.resumePossible(origin, newRule);\n    }\n    this.possibleArray[smallestGridIndex] = set;\n  }\n\n  resumePossible(origin, newRule) {\n    origin.forEach((set, index) => {\n      this.possibleArray[index] = set;\n    });\n    newRule.forEach((sets, index) => {\n      for (const index of sets) {\n        this.connectedRules[index].pop();\n      }\n      this.globalRules.pop();\n    });\n  }\n\n  largerSet(list, num) {\n    const ret = new Set([]);\n    for (const x of list) {\n      if (x > num) {\n        ret.add(x);\n      }\n    }\n    return ret;\n  }\n\n  smallSet(list, num) {\n    const ret = new Set([]);\n    for (const x of list) {\n      if (x < num) {\n        ret.add(x);\n      }\n    }\n    return ret;\n  }\n\n};\n\n//# sourceURL=webpack://Solver/./src/sudoku/index.js?");

/***/ }),

/***/ "./src/sudoku/solverParser.js":
/*!************************************!*\
  !*** ./src/sudoku/solverParser.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SolverParser\": () => (/* binding */ SolverParser)\n/* harmony export */ });\nconst colorMap = {\n  '黑': 'black',\n  '白': 'white',\n  '红': 'red',\n  '蓝': 'blue',\n  '黄': 'yellow'\n};\n\nclass SolverParser {\n\n  constructor(rulesList, n, m, globalRules, globalFinalRules) {\n    this.n = n;\n    this.m = m;\n    this.filledArea = [];\n    this.noMeet = false;\n    this.hashi = new Set();\n    this.hashiRules = [];\n    this.globalRules = globalRules;\n    this.globalFinalRules = globalFinalRules;\n    const lastParse = [];\n    for (let i = 0; i < rulesList.length; i++) {\n      const rule = rulesList[i].replace(/\\s/g, '');\n      if (rule[0] == '没' || rule.includes(\"空白的格子\")) {\n        lastParse.push(rule);\n      } else {\n        this.parseLine(rule);\n      }\n    }\n    for (const rule of lastParse) {\n      this.parseLine(rule);\n    }\n    if (this.hashiRules.length > 0) {\n      this.handleHashi(globalRules);\n    }\n  }\n\n  handleHashi(globalRules) {\n    const down = [];\n    const right = [];\n    const rightEnd = [];\n    const downEnd = [];\n    for (const hashiRule of this.hashiRules) {\n      for (let i = 0; i < hashiRule.restrictAreas.length; i++) {\n        const area = hashiRule.restrictAreas[i];\n        const neighbour = [area];\n        const row = area / m;\n        const col = area % m;\n        let L = false,\n            R = false,\n            U = false,\n            D = false;\n        const to = { u: null, d: null, l: null, r: null, self: area };\n        for (let cur = area - m; cur >= 0; cur -= m) {\n          // up\n          if (this.hashi.has(cur)) {\n            U = true;\n            neighbour.push(cur);\n            to.u = cur;\n            break;\n          }\n        }\n        for (let cur = area + m; cur < n * m; cur += m) {\n          // down\n          if (this.hashi.has(cur)) {\n            D = true;\n            neighbour.push(cur);\n            to.d = cur;\n            break;\n          }\n        }\n        if (D) {\n          downEnd.push(area);\n          for (let cur = area; cur < n * m; cur += m) {\n            // down\n            if (cur == to.d) break;\n            down[cur] = { u: area, d: to.d, rule: hashiRule.rules };\n          }\n        }\n        for (let i = col - 1, cur = area - 1; i >= 0; i--, cur--) {\n          if (this.hashi.has(cur)) {\n            L = true;\n            neighbour.push(cur);\n            to.l = cur;\n            break;\n          }\n        }\n        for (let i = col + 1, cur = area + 1; i < m; i++, cur++) {\n          if (this.hashi.has(cur)) {\n            R = true;\n            neighbour.push(cur);\n            to.r = cur;\n            break;\n          }\n        }\n        if (R) {\n          rightEnd.push(area);\n          for (let i = col, cur = area; i < m; i++, cur++) {\n            if (cur == to.r) break;\n            right[cur] = { l: area, r: to.r, rule: hashiRule.rules };\n          }\n        }\n        const rule = hashiRule.rules.hashi.limit;\n        const num = hashiRule.rules.hashi.number;\n        const set = [];\n        for (let u = 0; u <= rule[0]; u++) {\n          if (u > num) break;\n          if (!U && u > 0) break;\n          for (let d = 0; d <= rule[1]; d++) {\n            if (u + d > num) break;\n            if (!D && d > 0) break;\n            for (let l = 0; l <= rule[2]; l++) {\n              if (!L && l > 0) break;\n              const r = num - u - d - l;\n              if (r < 0) break;\n              if (!R && r > 0) continue;\n              if (r > rule[3]) continue;\n              set.push({ hashi: { u, d, l, r }, to });\n            }\n          }\n        }\n        hashiRule.rules.set = set;\n        hashiRule.rules.hashi.to = to;\n        hashiRule.rules.hashi.conflict = {};\n        globalRules.push({\n          restrictAreas: neighbour,\n          rules: hashiRule.rules\n        });\n      }\n    }\n\n    if (this.noMeet) {\n      for (const re of rightEnd) {\n        const rule = right[re].rule;\n        const rules = [];\n        for (let cur = re + 1; right[cur]; cur++) {\n          if (right[re].r === cur) break;\n          if (down[cur]) rules.push(down[cur].rule.hashi);\n        }\n        if (rules.length > 0) rule.hashi.conflict.r = { rules };\n      }\n\n      for (const de of downEnd) {\n        const rule = down[de].rule;\n        const rules = [];\n        for (let cur = de + m; cur < n * m; cur += m) {\n          // down\n          if (cur === down[de].d) break;\n          if (right[cur]) rules.push(right[cur].rule.hashi);\n        }\n        if (rules.length > 0) rule.hashi.conflict.d = { rules };\n      }\n    }\n  }\n\n  parseLine(lineStr, _globalFinalRules, _globalRules) {\n    const globalFinalRules = _globalFinalRules ? _globalFinalRules : this.globalFinalRules;\n    const globalRules = _globalRules ? _globalRules : this.globalRules;\n    if (lineStr === \"\") return;\n    if (this.specialRule(lineStr)) {\n      return;\n    }\n    const restrictAreas = this.getRestrictAreas(lineStr, 0);\n    const rules = this.getRules(lineStr, restrictAreas.stopPos);\n    if (rules === undefined) {\n      alert(`我不认识\"${lineStr}\"的规则，请仔细检查`);\n      return;\n    }\n    if (rules.hashi) {\n      for (let i = 0; i < restrictAreas.restrictArea.length; i++) {\n        for (const area of restrictAreas.restrictArea[i]) {\n          this.hashi.add(area);\n        }\n        this.hashiRules.push({\n          restrictAreas: restrictAreas.restrictArea[i],\n          rules\n        });\n      }\n    } else if (rules.smallerThan || rules.largerThan) {\n      for (let i = 0; i < restrictAreas.restrictArea.length; i++) {\n        globalFinalRules.push({\n          restrictAreas: restrictAreas.restrictArea[i],\n          rules\n        });\n      }\n    } else {\n      for (let i = 0; i < restrictAreas.restrictArea.length; i++) {\n        globalRules.push({\n          restrictAreas: restrictAreas.restrictArea[i],\n          rules\n        });\n      }\n    }\n  }\n\n  parseRelativeSign(str, start) {\n    if (str[start] === '是') {\n      return {\n        set: this.getSet(str, start + 1)\n      };\n    } else if (str[start] === '大') {\n      return {\n        largerThan: this.getNumber(str, start + 2).value\n      };\n    } else if (str[start] === '大' && str[start + 2] === '等') {\n      return {\n        largerThan: this.getNumber(str, start + 4).value - 1\n      };\n    } else if (str[start] === '小') {\n      return {\n        smallerThan: this.getNumber(str, start + 2).value\n      };\n    } else if (str[start] === '小' && str[start + 2] === '等') {\n      return {\n        smallerThan: this.getNumber(str, start + 4).value + 1\n      };\n    } else if (str[start] === '强') {\n      // 强制是xx\n      return {\n        set: this.getSet(str, start + 3),\n        force: true\n      };\n    }\n  }\n\n  getRules(str, start) {\n    let temp;\n    if (str[start] === '互') {\n      return {\n        isDifferent: true\n      };\n    } else if (str[start] === '按' && str[start + 1] === '顺') {\n      // 按顺序组成字母\n      return {\n        isWord: true\n      };\n    } else if (temp = this.parseRelativeSign(str, start)) {\n      return temp;\n    } else if (str[start] === '的' && str[start + 1] === '和') {\n      return {\n        sum: this.getNumber(str, start + 3).value\n      };\n    } else if (str[start] === '的' && str[start + 1] === '系') {\n      const coefficient = this.getNumberList(str, start + 4);\n      const number = this.getNumber(str, coefficient.stopPos + 6);\n      return {\n        linear: {\n          coefficient: coefficient.set.map(x => x + 1),\n          result: number.value\n        }\n      };\n    } else if (str[start] === '的') {\n      // 的（黑格/1/2/3）的数量(是)\n      const lineToken = this.getNumber(str, start + 1);\n      let currentPos;\n      let item;\n      if (lineToken) {\n        currentPos = lineToken.stopPos + 3;\n        item = lineToken.value;\n      } else {\n        currentPos = start + 6;\n        item = colorMap[str[start + 1]];\n      };\n      const result = this.parseRelativeSign(str, currentPos);\n      const ret = {\n        count: result\n      };\n      ret.count.item = item;\n\n      return ret;\n    } else if (str[start] === '从') {\n      //从上到下连续的黑格长度是\n      const list = this.getNumberList(str, start + 12).set.map(x => x + 1);\n      const type = str[start + 1] === '上' ? 'col' : 'row';\n      return {\n        bars: {\n          list,\n          type,\n          item: colorMap[str[start + 7]]\n        }\n      };\n    } else if (str[start] === '除') {\n      //除了黑格外的格子是\n      const list = this.getNumberList(str, start + 9).set;\n      return {\n        permutation: {\n          list\n        },\n        set: list\n      };\n    } else if (str[start] === '可' && str[start + 2] === '形') {\n      // 可以形成1条回路\n      const number = this.getNumber(str, start + 4).value;\n      return {\n        loop: {\n          number\n        },\n        set: ['UR', 'UB', 'UL', 'RB', 'RL', 'BL']\n      };\n    } else if (str[start] === '连') {\n      //连出的线段总数为3且上下左右线段数量不超过[2,2,2,2]\n      const number = this.getNumber(str, start + 8);\n      const list = this.getNumberList(str, number.stopPos + 12).set;\n      return {\n        hashi: {\n          number: number.value,\n          limit: list.map(x => x + 1)\n        }\n      };\n    }\n  }\n\n  getNumber(str, start) {\n    const number = str.substr(start).match(/^\\-*\\d+/);\n    if (!number) return null;\n    return {\n      value: parseInt(number[0]),\n      stopPos: start + number[0].length\n    };\n  }\n\n  getNumberList(str, start) {\n    let index = start + 1;\n    const ret = [];\n    while (1) {\n      let numberToken = this.getNumber(str, index);\n      if (numberToken) {\n        index = numberToken.stopPos + 1;\n        ret.push(numberToken.value - 1);\n      } else {\n        const start = index;\n        while (str[index] != ']' && str[index] != ',') {\n          index++;\n        }\n        ret.push(str.slice(start, index));\n        numberToken = { stopPos: index };\n        index++;\n      }\n      if (str[numberToken.stopPos] === ']') {\n        return {\n          stopPos: numberToken.stopPos + 1,\n          set: ret\n        };\n      }\n    }\n  }\n\n  getOriginAreas(str, start) {\n    const ret = [];\n    if (str[0] === '每') {\n      if (str.substr(1, 2) === '一行') {\n        for (let row = 0; row < this.n; row++) {\n          ret.push([]);\n          for (let col = 0; col < this.m; col++) {\n            ret[row].push(row * this.m + col);\n          }\n        }\n        return {\n          stopPos: 3,\n          restrictArea: ret\n        };\n      } else if (str.substr(1, 2) === '一列') {\n        for (let col = 0; col < this.n; col++) {\n          ret.push([]);\n          for (let row = 0; row < this.m; row++) {\n            ret[col].push(row * this.m + col);\n          }\n        }\n        return {\n          stopPos: 3,\n          restrictArea: ret\n        };\n      } else if (str.substr(1, 2) === '一格') {\n        for (let row = 0; row < this.n; row++) {\n          for (let col = 0; col < this.m; col++) {\n            ret.push(row * this.m + col);\n          }\n        }\n        return {\n          stopPos: 3,\n          restrictArea: [ret]\n        };\n      }\n    } else if (str[0] === '第') {\n      const lineToken = this.getNumber(str, 1);\n      if (lineToken) {\n        this.filledArea[lineToken.value - 1] = true;\n        if (str[lineToken.stopPos] === '行') {\n          for (let col = 0; col < this.m; col++) {\n            this.filledArea[(lineToken.value - 1) * m + col] = true;\n            ret.push((lineToken.value - 1) * m + col);\n          }\n        } else if (str[lineToken.stopPos] === '列') {\n          for (let row = 0; row < this.n; row++) {\n            this.filledArea[row * this.m + (lineToken.value - 1)] = true;\n            ret.push(row * this.m + (lineToken.value - 1));\n          }\n        } else if (str[lineToken.stopPos] === '格') {\n          ret.push(lineToken.value - 1);\n        }\n      } else if (str[start + 1] === '[') {\n        const list = this.getNumberList(str, start + 1);\n        return {\n          stopPos: list.stopPos + 1,\n          restrictArea: [list.set]\n        };\n      }\n      return {\n        stopPos: lineToken.stopPos + 1,\n        restrictArea: [ret]\n      };\n    }\n  }\n\n  getDir(str, start) {\n    if (str[start] === '本') {\n      // 本格\n      return {\n        stopPos: start + 2,\n        diff: {\n          dr: 0,\n          dc: 0\n        }\n      };\n    }\n    let currentPos = start;\n    let dr = 0;\n    let dc = 0;\n    while (1) {\n      let flag = 0;\n      switch (str[currentPos]) {\n        case '上':\n          dr--;\n          break;\n        case '下':\n          dr++;\n          break;\n        case '左':\n          dc--;\n          break;\n        case '右':\n          dc++;\n          break;\n        default:\n          flag = 1;\n      }\n      if (flag === 1) break;\n      currentPos++;\n    }\n    return {\n      stopPos: currentPos,\n      diff: {\n        dr,\n        dc\n      }\n    };\n  }\n\n  modifyArea(str, start, origin) {\n    if (str[start] === '[') {\n      let currentPos = start + 1;\n      const diffs = [];\n      while (1) {\n        const result = this.getDir(str, currentPos);\n        diffs.push(result.diff);\n        currentPos = result.stopPos + 1;\n        if (str[result.stopPos] === ']') break;\n      }\n      return { diffs, stopPos: currentPos };\n    }\n  }\n\n  getRestrictAreas(str, start) {\n    const ret = this.getOriginAreas(str, start);\n    if (str[ret.stopPos] === \"的\" && str[ret.stopPos + 1] === \"[\") {\n      let result = this.modifyArea(str, ret.stopPos + 1, ret);\n      const modifiedArea = ret.restrictArea[0].map(x => {\n        let c = x % this.m;\n        let r = parseInt(x / this.m);\n        const temp = [];\n        for (const d of result.diffs) {\n          const nc = c + d.dc;\n          const nr = r + d.dr;\n          if (nc < 0 || nc >= this.m || nr < 0 || nr >= this.n) continue;\n          temp.push(nr * this.m + nc);\n        }\n        return temp;\n      });\n      ret.restrictArea = modifiedArea;\n      ret.stopPos = result.stopPos;\n    } else if (str[ret.stopPos] == '空') {\n      // 空白的格子\n      const areas = [];\n      for (const area of ret.restrictArea) {\n        const temp = [];\n        for (const item of area) {\n          if (this.filledArea[item]) continue;\n          temp.push(item);\n        }\n        areas.push(temp);\n      }\n      ret.restrictArea = areas;\n      ret.stopPos += 5;\n    };\n    return ret;\n  }\n\n  getSet(str, start) {\n    const ret = [];\n    let currentPos = start;\n    while (1) {\n      if (!str[currentPos]) break;\n      const numberToken = this.getNumber(str, currentPos);\n\n      if (numberToken) {\n        ret.push(numberToken.value);\n        currentPos = numberToken.stopPos;\n      } else if (str[currentPos] === '从') {\n        let firstToken = this.getNumber(str, currentPos + 1);\n        let secondToken;\n        if (firstToken === null) {\n          firstToken = str[currentPos + 1];\n          if (str[currentPos + 2] === '到') {\n            secondToken = str[currentPos + 3];\n          }\n          for (let i = firstToken.charCodeAt(0); i <= secondToken.charCodeAt(0); i++) {\n            ret.push(String.fromCharCode(i).toLowerCase());\n          }\n          currentPos += 4;\n        } else {\n          if (str[firstToken.stopPos] === '到') {\n            secondToken = this.getNumber(str, firstToken.stopPos + 1);\n          }\n          for (let i = firstToken.value; i <= secondToken.value; i++) {\n            ret.push(i);\n          }\n          currentPos = secondToken.stopPos + 3;\n        }\n      } else if (str[currentPos] === '或') {\n        currentPos++;\n      } else if (str[currentPos] === '黑') {\n        ret.push('black');\n        currentPos += 2;\n      } else if (str[currentPos] === '白') {\n        ret.push('white');\n        currentPos += 2;\n      } else if (str[currentPos] === '红') {\n        ret.push('red');\n        currentPos += 2;\n      } else if (str[currentPos] === '蓝') {\n        ret.push('blue');\n        currentPos += 2;\n      } else if (str[currentPos].match(/[a-z]/i)) {\n        ret.push(str[currentPos]);\n        currentPos += 1;\n      } else {\n        break;\n      }\n    }\n    return ret;\n  }\n\n  specialRule(lineStr) {\n    if (lineStr[0] === '我') {\n      return true;\n    } else if (lineStr[0] === '如') {\n      const regexResult = lineStr.match(/^如果(?<ifCondition>(?<![,，]).*),那么(?<statement>.*)/).groups;\n      const condition = regexResult.ifCondition;\n      const statement = regexResult.statement;\n      if (condition === undefined || statement === undefined) {\n        alert(lineStr + \"不符合如果这条规则的规范\");\n      }\n      const conditionResult = [];\n      this.parseLine(condition, conditionResult, conditionResult);\n      const statementResult = [];\n      this.parseLine(statement, statementResult, statementResult);\n      for (const rule of conditionResult) {\n        const dummyRule = {\n          restrictAreas: rule.restrictAreas,\n          rules: {\n            ifCondition: {\n              condition: rule.rules,\n              statement: statementResult\n            }\n          }\n        };\n        this.globalRules.push(dummyRule);\n      }\n\n      return true;\n    } else if (lineStr[0] === '没') {\n      //没填的格子默认是\"第<格子序号>格的[本格,上,下,左,右,左上,右上,左下,右下]的黑格的数量是0\"\n      let content = lineStr.substr(9);\n      content = content.substr(0, content.length - 1);\n\n      for (let i = 0; i < this.n * this.m; i++) {\n        if (this.filledArea[i]) continue;\n        const contentSubstitue = content.replace(\"<格子序号>\", (i + 1).toString());\n        this.parseLine(contentSubstitue);\n      }\n\n      return true;\n    } else if (lineStr[0] === '线') {\n      //线段之间互不相交\n      this.noMeet = true;\n      return true;\n    }\n    return false;\n  }\n};\n\n//# sourceURL=webpack://Solver/./src/sudoku/solverParser.js?");

/***/ }),

/***/ "./src/word-search/wordSearch.js":
/*!***************************************!*\
  !*** ./src/word-search/wordSearch.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WordSearch\": () => (/* binding */ WordSearch)\n/* harmony export */ });\n/* harmony import */ var _common_Trie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Trie */ \"./src/common/Trie.js\");\n\n\n//import { words } from \"../common/dict\";\nclass WordSearch {\n    constructor() {}\n\n    customWordList(wordList) {\n        this.customTrie = new _common_Trie__WEBPACK_IMPORTED_MODULE_0__.Trie();\n        for (let word of wordList) {\n            if (!this.Trie.contains(word)) {\n                customTrie.insert(word);\n            }\n        }\n    }\n    contains(str) {\n        let currentNode = this.root;\n        for (let i = 0; i < str.length; i++) {\n            if (!currentNode[str[i]]) {\n                return false;\n            }\n            currentNode = currentNode[str[i]];\n        }\n        return currentNode.isWord;\n    }\n    search(x, y, dx, dy, filter) {\n        let currentX = x;\n        let currentY = y;\n        let str = \"\";\n        while (currentX < this.row && currentX >= 0 && currentY < this.column && currentY >= 0) {\n            str += this.matrix[currentX][currentY];\n            currentX += dx;\n            currentY += dy;\n        }\n        const answers = window.Trie.findAll(str).filter(word => word.length >= 2).map(word => {\n            return { word, x, y, dx, dy };\n        });\n        return answers;\n    }\n    wordSearch(matrix, filter) {\n        if (!filter) {\n            filter = {\n                length: 3\n            };\n        }\n        const dx = [-1, 0, 1, -1, 1, -1, 0, 1];\n        const dy = [1, 1, 1, 0, 0, -1, -1, -1];\n        this.matrix = matrix;\n        const answers = [];\n        const row = this.row = matrix.length;\n        const column = this.column = matrix[0].length;\n        for (let i = 0; i < row; i++) {\n            for (let j = 0; j < column; j++) {\n                // loop through 8 directions\n                for (let k = 0; k < 8; k++) {\n                    const currentAnswers = this.search(i, j, dx[k], dy[k], filter);\n                    for (let answer of currentAnswers) {\n                        answers.push(answer);\n                    }\n                }\n            }\n        }\n        return answers;\n    }\n    buildMatrix(str, row, column) {\n        let strWithOnlyEnglishLetter = str.replace(/[^A-Za-z\\n]/g, '').toLowerCase();\n        const returnMat = [];\n        row = 0;\n        if (!row || !column) {\n            const strSplit = strWithOnlyEnglishLetter.split(\"\\n\");\n            strWithOnlyEnglishLetter = strWithOnlyEnglishLetter.replace(/[\\n]/g, '');\n            for (let line of strSplit) {\n                if (line) {\n                    column = line.length;\n                    row++;\n                }\n            }\n        }\n        let index = 0;\n\n        for (let i = 0; i < row; i++) {\n            returnMat.push([]);\n            for (let j = 0; j < column; j++) {\n                if (!strWithOnlyEnglishLetter[index]) {\n                    throw new Error(\"StringTooShort\");\n                }\n                returnMat[i].push(strWithOnlyEnglishLetter[index]);\n                index++;\n            }\n        }\n        if (index < strWithOnlyEnglishLetter.length) {\n            throw new Error(\"StringTooLong\");\n        }\n        return returnMat;\n    }\n\n}\n\n//# sourceURL=webpack://Solver/./src/word-search/wordSearch.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});