!function(t,s){"object"==typeof exports&&"object"==typeof module?module.exports=s():"function"==typeof define&&define.amd?define([],s):"object"==typeof exports?exports.Solver=s():t.Solver=s()}(this,(function(){return(()=>{"use strict";var __webpack_modules__={895:(t,s,e)=>{e.d(s,{B:()=>r});class i{constructor(){this.isWord=!1}}class r{constructor(){this.root=new i}insert(t){if(!t)return;let s=this.root;for(let e=0;e<t.length;e++)s[t[e]]||(s[t[e]]=new i),s=s[t[e]];s.isWord=!0}contains(t){let s=this.root;for(let e=0;e<t.length;e++){if(!s[t[e]])return!1;s=s[t[e]]}return s.isWord}findAll(t){const s=[];let e=this.root,i="";for(let r=0;r<t.length;r++){const o=e[t[r]];if(i+=t[r],!o)break;o.isWord&&s.push(i),e=o}return s}dfs(t,s,e,i,r){if(s===t.length)return void(e.isWord&&r.push(i));const o=t[s];for(let n=0;n<o.length;n++){const l=o[n],h=e[l];h&&this.dfs(t,s+1,h,i+l,r)}}findAllByPossibleSets(t){const s=[];for(let e=0;e<t.length;e++){const i=t[e];s.push([...new Set(i)])}const e=[];return this.dfs(s,0,this.root,"",e),e}}},481:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{l:()=>OneWord});var _common_Trie__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(895);class OneWord{constructor(){this.initTrie()}initTrie(){const t=window.words;if(!window.Trie&&t){window.Trie=new _common_Trie__WEBPACK_IMPORTED_MODULE_0__.B;for(let s in t)if(s)for(let e of t[s])window.Trie.insert(e)}this.Trie=window.Trie}editDistance(t,s){if(t===s)return 0;var e=t.length,i=s.length;if(e&&i){for(var r,o,n,l,h=0,a=0,u=[];h<e;)u[h]=++h;for(;a<i;)for(l=s.charCodeAt(a),r=a,o=++a,h=0;h<e;++h)n=r+(t.charCodeAt(h)===l?0:1),o=o<(r=u[h])?o<n?o+1:n:r<n?r+1:n,u[h]=o;return o}return e+i}async findByRegularExpression(str,callback,filter){const words=window.words,regularExpression=eval(`/${str}/`),answer=[];callback||(callback=()=>{});for(let t in words){if(!t)continue;const s=t.length;for(let e=0;e<words[t].length;e++){const i=words[t][e];this.isFilter(t,e,filter)||regularExpression.test(i)&&(answer.push(i),await callback(s,i))}}return answer}findByWildcard(t,s,e){let i="";for(let s of t)i+="#"===s?".":"*"===s?".*":s;return this.findByRegularExpression(`^${i}$`,s,e)}isFilter(t,s,e){return!!window.c&&!!window.c[t]&&(0==(16&e)&&0==(16&window.c[t][s])||0==(e&window.c[t][s]))}makeLetterSet(t){const s=[];for(let e=0;e<t.length;e++)s[t[e]]||(s[t[e]]=0),s[t[e]]++;return s}async onlyContains(t,s){const e=window.words,i=[],r=this.makeLetterSet(t),o=(t,s)=>{const e=[];for(let i=0;i<s.length;i++){if(!t[s[i]])return!1;e[s[i]]||(e[s[i]]=0),e[s[i]]++}return!0};for(let t in e){if(!t)continue;const n=t.length;for(let l of e[t])o(r,l)&&(await s(n,l),i.push(l))}return i}permutation(t){const s=window.words,e=[],i=this.makeLetterSet(t),r=(t,s)=>{const e=[];for(let i=0;i<s.length;i++){if(!t[s[i]])return!1;e[s[i]]||(e[s[i]]=0),e[s[i]]++}for(let s in t)if(!e[s]||t[s]!=e[s])return!1;return!0};for(let t in s)if(t)for(let o of s[t])r(i,o)&&(console.info(o),e.push(o));return e}stringInclude(t,s){const e=[];for(let i=0;i<s.length;i++)t[s[i]]&&(e[s[i]]||(e[s[i]]=0),e[s[i]]++);for(let s in t)if(!e[s]||t[s]>e[s])return!1;return!0}async contains(t,s){const e=window.words,i=[];s||(s=()=>{});const r=this.makeLetterSet(t);for(let t in e){if(!t)continue;const o=t.length;for(let n of e[t])this.stringInclude(r,n)&&(i.push(n),await s(o,n))}return i}async findSimilarity(t,s,e){const i=window.words,r=[];s||(s=1),e||(e=()=>{});const o=t.length;for(let n in i){if(!n)continue;const l=n.length;if(!(Math.abs(l-o)>s))for(let o of i[n])this.editDistance(t,o)<=s&&(r.push(o),await e(l,o))}return r}async findByCode(t,s){const e=window.words,i=[];s||(s=()=>{});const r={isWord:t=>this.Trie.contains(t),anagram:(t,s)=>{const e=this.makeLetterSet(s);return this.stringInclude(e,t)}};try{var o=new Function(`return ${t}`)();if(!o)throw new Error("没有函数")}catch(t){throw alert(`程序错误，请仔细检查你的代码\n错误信息:\n${t.message}`),t}for(let t in e)if(t)for(let n of e[t]){let t;try{t=o(n,r)}catch(t){continue}t&&(i.push(t),await s(t.length,t))}console.info(t)}}}},__webpack_module_cache__={};function __webpack_require__(t){var s=__webpack_module_cache__[t];if(void 0!==s)return s.exports;var e=__webpack_module_cache__[t]={exports:{}};return __webpack_modules__[t](e,e.exports,__webpack_require__),e.exports}__webpack_require__.d=(t,s)=>{for(var e in s)__webpack_require__.o(s,e)&&!__webpack_require__.o(t,e)&&Object.defineProperty(t,e,{enumerable:!0,get:s[e]})},__webpack_require__.o=(t,s)=>Object.prototype.hasOwnProperty.call(t,s),__webpack_require__.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var __webpack_exports__={};return(()=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{OneWord:()=>r.l,RubikCubeStage:()=>p,SubstitutionSolver:()=>i,SudokuSolver:()=>b,WordSearch:()=>l});class t{constructor(){this.mode=t.impossible,this.matrix=new Array(26),this.ensure=new Array(26);for(let s=0;s<26;s++){this.matrix[String.fromCharCode(97+s)]=new Array(26);let e=this.matrix[String.fromCharCode(97+s)];for(let s=0;s<26;s++)e[String.fromCharCode(97+s)]=t.possible}}init(){this.matrix=new Array(26),this.ensure=new Array(26);for(let s=0;s<26;s++){this.matrix[String.fromCharCode(97+s)]=new Array(26);let e=this.matrix[String.fromCharCode(97+s)];for(let s=0;s<26;s++)e[String.fromCharCode(97+s)]=t.possible}this.mode=t.impossible}disallow(t,s){const e=this.matrix[t][s]!==this.mode;return this.matrix[t][s]=this.mode,e}unique(s){let e=0;for(let i=0;i<26;i++)if(this.matrix[s][String.fromCharCode(97+i)]===t.possible&&(this.ensure[s]=String.fromCharCode(97+i),e++,e>1))return this.ensure[s]=null,!1;return!0}getAllowedChars(s){const e=new Array;for(let i=0;i<26;i++)this.matrix[s][String.fromCharCode(97+j)]!==t.impossible&&e.push(String.fromCharCode(97+j));return e}isAllowed(t,s){return this.matrix[t][s]}mapMode(t){this.mode=t}copy(){const s=new t;s.ensure=[].concat(this.ensure);for(let t=0;t<26;t++)for(let e=0;e<26;e++)s.matrix[String.fromCharCode(97+t)][String.fromCharCode(97+e)]=this.matrix[String.fromCharCode(97+t)][String.fromCharCode(97+e)];return s}}t.guessPossible=3,t.guessImpossible=2,t.possible=1,t.impossible=0;class s{constructor(t,s,e){this.word=t,this.possibleList=JSON.parse(JSON.stringify(s)),this.position=e}eliminate(s){for(var e=this.word.length,i=this.possibleList.length,r=new Array,o=!1,n=0;n<i;n++){var l=this.possibleList[n];if(void 0!==l){for(var h=0;h<e;h++)if(s.isAllowed(this.word[h],l[h])===t.impossible){r[n]=1,o=!0;break}}else r[n]=1}for(n=i-1;n>=0;n--)1===r[n]&&this.possibleList.splice(n,1);return o}trimMappingTable(s){for(var e=this.word.length,i=this.possibleList.length,r=new Array(26),o=!1,n=0;n<e;n++){for(var l=0;l<26;l++)r[l]=t.impossible;var h=this.word[n];for(l=0;l<i;l++)r[this.possibleList[l].charCodeAt(n)-97]=t.possible;for(l=0;l<26;l++)if(r[l]!==t.possible){const t=s.disallow(this.word[n],String.fromCharCode(97+l));o=o||t}if(!0===s.unique(h)){const t=s.ensure[h];for(l=0;l<26;l++)h!==String.fromCharCode(l+97)&&(o=s.disallow(String.fromCharCode(97+l),t)||o)}}return o}customize(t){let s=this.eliminate(t),e=this.trimMappingTable(t);return s||e}copy(){return new s(this.word,this.possibleList,this.position)}}class e{constructor(){this._list=[]}pattern(t){for(var s=0,e=t.length,i="",r=new Array(26),o=0;o<e;o++)null==r[t[o]]&&(r[t[o]]=String.fromCharCode(s+97),s++),i+=r[t[o]];return i}generateWeight(t,s){const e=t.length;if(e>10)for(let i=0;i<e;i++)s[t[i]]=e>100&&i<=10?17:i/e<.4?15:i/e<.6?8:i/e<.9?1:-1;else for(let i=0;i<e;i++)s[t[i]]=e-i}build(t,e,i,r){const o=window.words,n=t.length;for(let l=0;l<n;l++)if(""!=t[l])if(t[l].includes("'")){const e=t[l].split("'");if(e[1]&&1===e[1].length){const t=new s(e[1],["s","t","d"],l);this._list.push(t)}}else{const n=o[this.pattern(t[l])].slice(0);this.generateWeight(n,r);const h=new s(t[l],n,l);h.customize(i),h.possibleList.length>1?this._list.push(h):e.list[h.position]=h}}set list(t){this._list=t}get list(){return this._list}push(t){this._list.push(t)}copy(){const t=new e;for(let s=0;s<this._list.length;s++){const e=this._list[s];e&&(t.list[s]=e.copy())}return t}getMinPossibleList(){var t=this._list[0].possibleList.length,s=0;for(let e=0;e<this._list.length;e++)t>this._list[e].possibleList.length&&(t=this._list[e].possibleList.length,s=e);return s}refreshByMappintTable(t,s){var e=0;const i=this._list;let r=0;for(;i.length>0;){var o=i.shift();const n=o.customize(s);if(o.possibleList.length>1)i.push(o);else{if(0===o.possibleList.length)return!1;t.list[o.position]=o}if(++e-r>i.length)break;n&&(r=e)}return!0}refreshByMappintTable2(t,s){let e=this._list;for(;;){let r=!1,o=[];for(let n=0;n<e.length;n++){var i=e[n];if(r=i.customize(s)||r,i.possibleList.length>1)o.push(i);else{if(0===i.possibleList.length)return this._list=e,!1;t.list[i.position]=i}}if(e=o,!1===r)break}return this._list=e,!0}empty(){return 0===this._list.length}setPossibleList(t,s){this._list[t].possibleList=[],this._list[t].possibleList.push(s)}}class i{constructor(){this.globleAns=[],this.ans=new Array,this.weight=[],this.threshold=10}substituteSolver(s,i,r){this.threshold=r||10,this.maxOutput=i||3e3;var o=(s=s.toLowerCase()).split(/[^a-zA-Z\']+/),n=new t,l=new e;this.globleAns=[],this.ans=[];var h=new e;return l.build(o,h,n,this.weight),l.refreshByMappintTable(h,n),this.dfsNonRecursion(l,h,n),this.globleAns.sort(((t,s)=>s.weight-t.weight)),console.info(this.globleAns),this.globleAns.map((t=>t.ret))}output(t){let s="",e=0;for(let i of t.list)s+=i.possibleList[0]+" ",e+=this.weight[i.possibleList[0]];this.globleAns.push({ret:s,weight:e})}dfs(t,s,e){if(t.empty())return void this.output(s);const i=t.getMinPossibleList(),r=t.list[i].possibleList.length;for(var o=0;o<r;o++){const r=t.list[i].possibleList[o],n=t.copy(),l=s.copy(),h=e.copy();n.setPossibleList(i,r),!1!==n.refreshByMappintTable(l,h)&&this.dfs(n,l,h)}}dfsNonRecursion(t,s,e){let i=new Array;i.push({unknownWordsList:t,knownWordsList:s,mappingTable:e});let r=0,o=new Array;for(;i.length>0||o.length>0;){for(;i.length>0;){const t=i.pop();if(t.unknownWordsList.empty()){if(this.output(t.knownWordsList),r++,r>this.maxOutput)return;continue}const s=t.unknownWordsList.getMinPossibleList(),e=t.unknownWordsList.list[s].possibleList.length,l=Math.min(e,this.threshold);for(var n=0;n<l;n++){const e=t.unknownWordsList.list[s].possibleList[n],r=t.unknownWordsList.copy(),o=t.knownWordsList.copy(),l=t.mappingTable.copy();r.setPossibleList(s,e),!1!==r.refreshByMappintTable(o,l)&&i.push({unknownWordsList:r,knownWordsList:o,mappingTable:l})}t.unknownWordsList.list[s].possibleList=t.unknownWordsList.list[s].possibleList.slice(l),!1!==t.unknownWordsList.refreshByMappintTable(t.knownWordsList,t.mappingTable)&&o.push({unknownWordsList:t.unknownWordsList,knownWordsList:t.knownWordsList,mappingTable:t.mappingTable})}i=o,o=new Array}}}var r=__webpack_require__(481),o=__webpack_require__(895);class l{constructor(){}customWordList(t){this.customTrie=new o.B;for(let s of t)this.Trie.contains(s)||customTrie.insert(s)}contains(t){let s=this.root;for(let e=0;e<t.length;e++){if(!s[t[e]])return!1;s=s[t[e]]}return s.isWord}search(t,s,e,i,r){let o=t,n=s,l="";for(;o<this.row&&o>=0&&n<this.column&&n>=0;)l+=this.matrix[o][n],o+=e,n+=i;return window.Trie.findAll(l).filter((t=>t.length>=2)).map((r=>({word:r,x:t,y:s,dx:e,dy:i})))}wordSearch(t,s){s||(s={length:3});const e=[-1,0,1,-1,1,-1,0,1],i=[1,1,1,0,0,-1,-1,-1];this.matrix=t;const r=[],o=this.row=t.length,n=this.column=t[0].length;for(let t=0;t<o;t++)for(let o=0;o<n;o++)for(let n=0;n<8;n++){const l=this.search(t,o,e[n],i[n],s);for(let t of l)r.push(t)}return r}buildMatrix(t,s,e){let i=t.replace(/[^A-Za-z\n]/g,"").toLowerCase();const r=[];if(!(s=0)||!e){const t=i.split("\n");i=i.replace(/[\n]/g,"");for(let i of t)i&&(e=i.length,s++)}let o=0;for(let t=0;t<s;t++){r.push([]);for(let s=0;s<e;s++){if(!i[o])throw new Error("StringTooShort");r[t].push(i[o]),o++}}if(o<i.length)throw new Error("StringTooLong");return r}}class h{constructor(t,s,e){this.angleX=0,this.angleY=0,this.angleZ=0,this.originX=t,this.originY=s,this.originZ=e,this.x=t,this.y=s,this.z=e,this.mat=[[1,0,0],[0,1,0],[0,0,1]]}multiply(t,s){const e=[[0,0,0],[0,0,0],[0,0,0]];for(let i=0;i<3;i++)for(let r=0;r<3;r++)for(let o=0;o<3;o++)e[i][r]+=t[i][o]*s[o][r];return e}rotateHelp(t,s){let e=this.originX,i=this.originY,r=this.originZ;switch(s){case"x":i=this.originY*Math.cos(t)-this.originZ*Math.sin(t),r=this.originY*Math.sin(t)+this.originZ*Math.cos(t);break;case"y":e=this.originX*Math.cos(t)+this.originZ*Math.sin(t),r=-this.originX*Math.sin(t)+this.originZ*Math.cos(t);break;case"z":e=this.originX*Math.cos(t)-this.originY*Math.sin(t),i=this.originX*Math.sin(t)+this.originY*Math.cos(t)}this.originX=e,this.originY=i,this.originZ=r}rotate(t,s,e){const i=[[1,0,0],[0,1,0],[0,0,1]],r=t*Math.PI/180;if(!0===e)this.rotateHelp(r,s);else switch(s){case"x":i[1][1]=Math.cos(r),i[1][2]=-Math.sin(r),i[2][1]=Math.sin(r),i[2][2]=Math.cos(r),this.angleX+=t;break;case"y":i[0][0]=Math.cos(r),i[2][0]=-Math.sin(r),i[0][2]=Math.sin(r),i[2][2]=Math.cos(r),this.angleY+=t;break;case"z":i[0][0]=Math.cos(r),i[0][1]=-Math.sin(r),i[1][0]=Math.sin(r),i[1][1]=Math.cos(r),this.angleZ+=t}this.mat=this.multiply(this.mat,i);const o=this.originX*this.mat[0][0]+this.originY*this.mat[0][1]+this.originZ*this.mat[0][2],n=this.originX*this.mat[1][0]+this.originY*this.mat[1][1]+this.originZ*this.mat[1][2],l=this.originX*this.mat[2][0]+this.originY*this.mat[2][1]+this.originZ*this.mat[2][2];this.x=o,this.y=n,this.z=l}resetRotation(){this.mat=[[1,0,0],[0,1,0],[0,0,1]],this.rotate("x",0)}}class a{constructor(t,s,e,i,r,o,n){this.points=[t,s,e,i],this.len=r,o||(o="red"),this.color=o,this.index=n}render(t,s,e){const i=new h(this.points[1].x-this.points[0].x,this.points[1].y-this.points[0].y,this.points[1].z-this.points[0].z),r=new h(this.points[3].x-this.points[0].x,this.points[3].y-this.points[0].y,this.points[3].z-this.points[0].z);if(new h(i.y*r.z-r.y*i.z,i.z*r.x-r.z*i.x,i.x*r.y-r.x*i.y).x<=0)return;const o=150,n=new h(this.points[0].y+o,this.points[0].z+o),l=new h(this.points[1].y+o,this.points[1].z+o),a=(new h(this.points[2].y+o,this.points[2].z+o),new h(this.points[3].y+o,this.points[3].z+o));t.beginPath(),t.moveTo(this.points[0].y+o,this.points[0].z+o),t.lineTo(this.points[1].y+o,this.points[1].z+o),t.lineTo(this.points[2].y+o,this.points[2].z+o),t.lineTo(this.points[3].y+o,this.points[3].z+o),t.lineTo(this.points[0].y+o,this.points[0].z+o),t.lineWidth=1,t.stroke();let u=Math.sqrt((n.x-a.x)*(n.x-a.x)+(n.y-a.y)*(n.y-a.y))/this.len;u=(n.y-a.y)/this.len;let c=-(l.x-n.x)/this.len,f=(l.y-n.y)/(l.x-n.x),p=(a.x-n.x)/(a.y-n.y);Math.abs(a.y-n.y)<1e-7&&(p=0),t.setTransform(c,f*c,p*u,u,this.points[3].y+o,this.points[3].z+o),t.fillStyle=this.color,e?t.drawImage(e,-this.len,0,this.len,this.len):t.fillRect(-this.len,0,this.len,this.len),t.setTransform(1,0,0,1,0,0)}}class u{constructor(t,s,e,i){this.index=i,e||(e=[]);const r=[];for(let e=0;e<8;e++)r.push(new h(t.x+(1&e)*s,t.y+(e>>1&1)*s,t.z+(e>>2&1)*s));const o=[[2,0,1,3],[5,7,3,1],[4,6,7,5],[6,4,0,2],[7,6,2,3],[4,5,1,0]];this.faces=[];const n=o.length,l=[];let u=0;for(let t=0;t<n;t++){if(null===e[t])continue;l[o[t][0]]=!0,l[o[t][1]]=!0,l[o[t][2]]=!0,l[o[t][3]]=!0;const i=new a(r[o[t][0]],r[o[t][1]],r[o[t][2]],r[o[t][3]],s,e[t],u++);this.faces.push(i)}this.points=[];for(let t=0;t<8;t++)!0===l[t]&&this.points.push(r[t])}render(t,s){for(let e of this.faces){let i=s?s[e.index]:null;e.render(t,this.index,i)}}rotate(t,s,e){for(let i of this.points)i.rotate(t,s,e)}resetRotation(){for(let t of this.points)t.resetRotation()}}class c{ontheEdge(t){return 0===t||t===this.degree-1}constructor(t,s,e,i){e||(e=3),this.degree=e,this.blockSize=s/e,this.materials=i,this.cubes=[];const r=["white","orange","yellow","red","blue","green"];let o=0;for(let s=0;s<e;s++)for(let i=0;i<e;i++)for(let n=0;n<e;n++){if(!this.ontheEdge(s)&&!this.ontheEdge(i)&&!this.ontheEdge(n))continue;const l=new h(t.x+s*this.blockSize,t.y+i*this.blockSize,t.z+n*this.blockSize),a=r.slice(0);0!=n&&(a[0]=null),n!=e-1&&(a[2]=null),s!=e-1&&(a[1]=null),0!=s&&(a[3]=null),i!=e-1&&(a[4]=null),0!=i&&(a[5]=null);const c=new u(l,this.blockSize,a,o++);this.cubes.push(c)}}render(t){const s=this.cubes.slice(0);s.sort(((t,s)=>s.points[0].x-t.points[0].x));for(let e of s){const s=this.materials?this.materials[e.index]:null;e.render(t,s)}}rotate(t,s){for(let e of this.cubes)e.rotate(t,s)}resetRotation(){for(let t of this.cubes)t.resetRotation()}permutation(t,s){for(let e of t){const t=e.length;if(1===s)for(let s=0;s<t-1;s++){const t=this.cubes[e[s]];this.cubes[e[s]]=this.cubes[e[s+1]],this.cubes[e[s+1]]=t}else for(let s=t-1;s>=1;s--){const t=this.cubes[e[s]];this.cubes[e[s]]=this.cubes[e[s-1]],this.cubes[e[s-1]]=t}}}rotateLayer(t,s,e){for(let i of t){const t=i.length;for(let r=0;r<t;r++)this.cubes[i[r]].rotate(90*s,e,!0)}}front(t){const s=[[2,8,6,0],[1,5,7,3],[4]];this.rotateLayer(s,t,"x"),this.permutation(s,t)}up(t){const s=[[0,6,23,17],[3,14,20,9],[12]];this.rotateLayer(s,t,"z"),this.permutation(s,t)}back(t){const s=[[22,24,20,18],[19,25,23,17],[21]];this.rotateLayer(s,t,"x"),this.permutation(s,t)}bottom(t){const s=[[11,5,16,22],[19,2,8,25],[13]];this.rotateLayer(s,t,"z"),this.permutation(s,t)}left(t){const s=[[0,17,19,2],[1,9,18,11],[10]];this.rotateLayer(s,t,"y"),this.permutation(s,t)}right(t){const s=[[8,6,23,25],[16,7,14,24],[15]];this.rotateLayer(s,t,"y"),this.permutation(s,t)}}class f{constructor(t){this.objList=[],this.ctx=t}add(t){this.objList.push(t)}render(){for(let t of this.objList)t.render(this.ctx)}}class p{constructor(t,s,e,i){this.ctx=t,this.width=s,this.height=e,this.rotationAngle={x:20,y:20,z:20};const r=this.makeMaterials(i);this.cube=new c(new h(-75,-75,-75),150,3,r),this.rotate(this.rotationAngle),this.draw(this.rotationAngle),this.register()}makeMaterials(t){const s=[{index:0,arr:[6,18,11]},{index:1,arr:[21,14]},{index:2,arr:[36,24,17]},{index:3,arr:[7,19]},{index:4,arr:[22]},{index:5,arr:[37,25]},{index:6,arr:[8,20,27]},{index:7,arr:[23,30]},{index:8,arr:[38,26,33]},{index:9,arr:[3,10]},{index:10,arr:[13]},{index:11,arr:[39,16]},{index:12,arr:[4]},{index:13,arr:[40]},{index:14,arr:[5,28]},{index:15,arr:[31]},{index:16,arr:[41,34]},{index:17,arr:[0,51,9]},{index:18,arr:[48,12]},{index:19,arr:[45,42,15]},{index:20,arr:[1,52]},{index:21,arr:[49]},{index:22,arr:[46,43]},{index:23,arr:[2,53,29]},{index:24,arr:[50,32]},{index:25,arr:[47,44,35]}],e=[];for(let i of s){e[i.index]=[];for(let s of i.arr)e[i.index].push(t[s])}return e}rotate(t){this.rotationAngle={x:this.rotationAngle.x+t.x,y:this.rotationAngle.y+t.y,z:this.rotationAngle.z+t.z};const s=this.cube;s.rotate(t.x,"x"),s.rotate(t.y,"y"),s.rotate(t.z,"z")}draw(){const t=this.cube;this.ctx.clearRect(0,0,this.width,this.height);const s=new f(this.ctx);s.add(t),s.render()}resetRotation(){this.cube.resetRotation()}front(t){t||(t=1),this.cube.front(t),this.draw()}up(t){t||(t=1),this.cube.up(t),this.draw()}back(t){t||(t=1),this.cube.back(t),this.draw()}bottom(t){t||(t=1),this.cube.bottom(t),this.draw()}left(t){t||(t=1),this.cube.left(t),this.draw()}right(t){t||(t=1),this.cube.right(t),this.draw()}register(){const t=this;let s={},e=!1;$("#rubik-cube").mousedown((t=>{if(1===t.which){var i=t.pageX,r=t.pageY;!1===e&&(s.x=i,s.y=r),e=!0}})),$("body").mouseup((s=>{if(!0===e){e=!1,t.resetRotation();const s={x:20,y:20,z:20};t.rotate(s),t.draw()}})),$("body").mousemove((i=>{if(!0===e){const e={x:0,y:0,z:0};let r=i.pageX,o=i.pageY,n=r-s.x,l=o-s.y;e.z=-n,e.y=l,t.rotate(e),t.draw(),s.x=r,s.y=o}})),$("#rubik-cube").on("touchstart",(function(t){var i=t.originalEvent.changedTouches[0].pageX,r=t.originalEvent.changedTouches[0].pageY;!1===e&&(s.x=i,s.y=r),e=!0,t.preventDefault()})),$("#rubik-cube").on("touchend",(function(s){if(!0===e){e=!1,t.resetRotation();const i={x:20,y:20,z:20};t.rotate(i),t.draw(),s.preventDefault()}})),$("#rubik-cube").on("touchmove",(function(i){if(!0===e){const e={x:0,y:0,z:0};var r=i.originalEvent.changedTouches[0].pageX,o=i.originalEvent.changedTouches[0].pageY;let n=r-s.x,l=o-s.y;e.z=-n,e.y=l,t.rotate(e),t.draw(),console.info(n),s.x=r,s.y=o}}));var i=function(t,s){this.x=t,this.y=s};let r=!1,o=new Array;function n(t,s,e){const r=$("#penColor").val();e.strokeStyle=r;const n=$("#penWidth").val();e.lineWidth=parseInt(n),e.beginPath();var l=o[o.length-1];e.moveTo(l.x,l.y),e.lineTo(t,s),e.closePath(),e.stroke(),o.push(new i(t,s))}$(".cube-block").mousedown((function(t){if(1==t.which){r=!0;var s=t.pageX-this.offsetLeft,e=t.pageY-this.offsetTop;o.push(new i(s,e))}})),$(".cube-block").on("touchstart",(function(t){var s=t.originalEvent.changedTouches[0].pageX-this.offsetLeft,e=t.originalEvent.changedTouches[0].pageY-this.offsetTop;r=!0,o.push(new i(s,e)),t.preventDefault()})),$(".cube-block").on("touchend",(function(s){r=!1,t.draw(),s.preventDefault()})),$(".cube-block").on("touchmove",(function(t){r&&n(t.originalEvent.changedTouches[0].pageX-this.offsetLeft,t.originalEvent.changedTouches[0].pageY-this.offsetTop,t.currentTarget.getContext("2d"))})),$(window).mouseup((function(s){r=!1,t.draw()})),$(".cube-block").mousemove((function(t){r&&n(t.pageX-this.offsetLeft,t.pageY-this.offsetTop,t.currentTarget.getContext("2d"))}))}}const d={黑:"black",白:"white",红:"red",蓝:"blue",黄:"yellow"};class g{constructor(t,s,e,i,r){this.n=s,this.m=e,this.filledArea=[],this.noMeet=!1,this.hashi=new Set,this.hashiRules=[],this.globalRules=i,this.globalFinalRules=r;const o=[];for(let s=0;s<t.length;s++){const e=t[s].replace(/\s/g,"");"没"==e[0]||e.includes("空白的格子")?o.push(e):this.parseLine(e)}for(const t of o)this.parseLine(t);this.hashiRules.length>0&&this.handleHashi(i)}handleHashi(t){const s=[],e=[],i=[],r=[];for(const o of this.hashiRules)for(let l=0;l<o.restrictAreas.length;l++){const h=o.restrictAreas[l],a=[h],u=(m,h%m);let c=!1,f=!1,p=!1,d=!1;const g={u:null,d:null,l:null,r:null,self:h};for(let t=h-m;t>=0;t-=m)if(this.hashi.has(t)){p=!0,a.push(t),g.u=t;break}for(let t=h+m;t<n*m;t+=m)if(this.hashi.has(t)){d=!0,a.push(t),g.d=t;break}if(d){r.push(h);for(let t=h;t<n*m&&t!=g.d;t+=m)s[t]={u:h,d:g.d,rule:o.rules}}for(let t=u-1,s=h-1;t>=0;t--,s--)if(this.hashi.has(s)){c=!0,a.push(s),g.l=s;break}for(let t=u+1,s=h+1;t<m;t++,s++)if(this.hashi.has(s)){f=!0,a.push(s),g.r=s;break}if(f){i.push(h);for(let t=u,s=h;t<m&&s!=g.r;t++,s++)e[s]={l:h,r:g.r,rule:o.rules}}const b=o.rules.hashi.limit,w=o.rules.hashi.number,y=[];for(let t=0;t<=b[0]&&!(t>w)&&(p||!(t>0));t++)for(let s=0;s<=b[1]&&!(t+s>w)&&(d||!(s>0));s++)for(let e=0;e<=b[2]&&(c||!(e>0));e++){const i=w-t-s-e;if(i<0)break;!f&&i>0||i>b[3]||y.push({hashi:{u:t,d:s,l:e,r:i},to:g})}o.rules.set=y,o.rules.hashi.to=g,o.rules.hashi.conflict={},t.push({restrictAreas:a,rules:o.rules})}if(this.noMeet){for(const t of i){const i=e[t].rule,r=[];for(let i=t+1;e[i]&&e[t].r!==i;i++)s[i]&&r.push(s[i].rule.hashi);r.length>0&&(i.hashi.conflict.r={rules:r})}for(const t of r){const i=s[t].rule,r=[];for(let i=t+m;i<n*m&&i!==s[t].d;i+=m)e[i]&&r.push(e[i].rule.hashi);r.length>0&&(i.hashi.conflict.d={rules:r})}}}parseLine(t,s,e){const i=s||this.globalFinalRules,r=e||this.globalRules;if(""===t)return;if(this.specialRule(t))return;const o=this.getRestrictAreas(t,0),n=this.getRules(t,o.stopPos);if(void 0!==n)if(n.hashi)for(let t=0;t<o.restrictArea.length;t++){for(const s of o.restrictArea[t])this.hashi.add(s);this.hashiRules.push({restrictAreas:o.restrictArea[t],rules:n})}else if(n.smallerThan||n.largerThan)for(let t=0;t<o.restrictArea.length;t++)i.push({restrictAreas:o.restrictArea[t],rules:n});else for(let t=0;t<o.restrictArea.length;t++)r.push({restrictAreas:o.restrictArea[t],rules:n});else alert(`我不认识"${t}"的规则，请仔细检查`)}parseRelativeSign(t,s){return"是"===t[s]?{set:this.getSet(t,s+1)}:"大"===t[s]?{largerThan:this.getNumber(t,s+2).value}:"大"===t[s]&&"等"===t[s+2]?{largerThan:this.getNumber(t,s+4).value-1}:"小"===t[s]?{smallerThan:this.getNumber(t,s+2).value}:"小"===t[s]&&"等"===t[s+2]?{smallerThan:this.getNumber(t,s+4).value+1}:"强"===t[s]?{set:this.getSet(t,s+3),force:!0}:void 0}getRules(t,s){let e;if("互"===t[s])return{isDifferent:!0};if("按"===t[s]&&"顺"===t[s+1])return{isWord:!0};if(e=this.parseRelativeSign(t,s))return e;if("的"===t[s]&&"和"===t[s+1])return{sum:this.getNumber(t,s+3).value};if("的"===t[s]&&"系"===t[s+1]){const e=this.getNumberList(t,s+4),i=this.getNumber(t,e.stopPos+6);return{linear:{coefficient:e.set.map((t=>t+1)),result:i.value}}}if("的"===t[s]){const e=this.getNumber(t,s+1);let i,r;e?(i=e.stopPos+3,r=e.value):(i=s+6,r=d[t[s+1]]);const o={count:this.parseRelativeSign(t,i)};return o.count.item=r,o}if("从"===t[s])return{bars:{list:this.getNumberList(t,s+12).set.map((t=>t+1)),type:"上"===t[s+1]?"col":"row",item:d[t[s+7]]}};if("除"===t[s]){const e=this.getNumberList(t,s+9).set;return{permutation:{list:e},set:e}}if("可"===t[s]&&"形"===t[s+2])return{loop:{number:this.getNumber(t,s+4).value},set:["UR","UB","UL","RB","RL","BL"]};if("连"===t[s]){const e=this.getNumber(t,s+8),i=this.getNumberList(t,e.stopPos+12).set;return{hashi:{number:e.value,limit:i.map((t=>t+1))}}}}getNumber(t,s){const e=t.substr(s).match(/^\-*\d+/);return e?{value:parseInt(e[0]),stopPos:s+e[0].length}:null}getNumberList(t,s){let e=s+1;const i=[];for(;;){let s=this.getNumber(t,e);if(s)e=s.stopPos+1,i.push(s.value-1);else{const r=e;for(;"]"!=t[e]&&","!=t[e];)e++;i.push(t.slice(r,e)),s={stopPos:e},e++}if("]"===t[s.stopPos])return{stopPos:s.stopPos+1,set:i}}}getOriginAreas(t,s){const e=[];if("每"===t[0]){if("一行"===t.substr(1,2)){for(let t=0;t<this.n;t++){e.push([]);for(let s=0;s<this.m;s++)e[t].push(t*this.m+s)}return{stopPos:3,restrictArea:e}}if("一列"===t.substr(1,2)){for(let t=0;t<this.n;t++){e.push([]);for(let s=0;s<this.m;s++)e[t].push(s*this.m+t)}return{stopPos:3,restrictArea:e}}if("一格"===t.substr(1,2)){for(let t=0;t<this.n;t++)for(let s=0;s<this.m;s++)e.push(t*this.m+s);return{stopPos:3,restrictArea:[e]}}}else if("第"===t[0]){const i=this.getNumber(t,1);if(i)if(this.filledArea[i.value-1]=!0,"行"===t[i.stopPos])for(let t=0;t<this.m;t++)this.filledArea[(i.value-1)*m+t]=!0,e.push((i.value-1)*m+t);else if("列"===t[i.stopPos])for(let t=0;t<this.n;t++)this.filledArea[t*this.m+(i.value-1)]=!0,e.push(t*this.m+(i.value-1));else"格"===t[i.stopPos]&&e.push(i.value-1);else if("["===t[s+1]){const e=this.getNumberList(t,s+1);return{stopPos:e.stopPos+1,restrictArea:[e.set]}}return{stopPos:i.stopPos+1,restrictArea:[e]}}}getDir(t,s){if("本"===t[s])return{stopPos:s+2,diff:{dr:0,dc:0}};let e=s,i=0,r=0;for(;;){let s=0;switch(t[e]){case"上":i--;break;case"下":i++;break;case"左":r--;break;case"右":r++;break;default:s=1}if(1===s)break;e++}return{stopPos:e,diff:{dr:i,dc:r}}}modifyArea(t,s,e){if("["===t[s]){let e=s+1;const i=[];for(;;){const s=this.getDir(t,e);if(i.push(s.diff),e=s.stopPos+1,"]"===t[s.stopPos])break}return{diffs:i,stopPos:e}}}getRestrictAreas(t,s){const e=this.getOriginAreas(t,s);if("的"===t[e.stopPos]&&"["===t[e.stopPos+1]){let s=this.modifyArea(t,e.stopPos+1,e);const i=e.restrictArea[0].map((t=>{let e=t%this.m,i=parseInt(t/this.m);const r=[];for(const t of s.diffs){const s=e+t.dc,o=i+t.dr;s<0||s>=this.m||o<0||o>=this.n||r.push(o*this.m+s)}return r}));e.restrictArea=i,e.stopPos=s.stopPos}else if("空"==t[e.stopPos]){const t=[];for(const s of e.restrictArea){const e=[];for(const t of s)this.filledArea[t]||e.push(t);t.push(e)}e.restrictArea=t,e.stopPos+=5}return e}getSet(t,s){const e=[];let i=s;for(;t[i];){const s=this.getNumber(t,i);if(s)e.push(s.value),i=s.stopPos;else if("从"===t[i]){let s,r=this.getNumber(t,i+1);if(null===r){r=t[i+1],"到"===t[i+2]&&(s=t[i+3]);for(let t=r.charCodeAt(0);t<=s.charCodeAt(0);t++)e.push(String.fromCharCode(t).toLowerCase());i+=4}else{"到"===t[r.stopPos]&&(s=this.getNumber(t,r.stopPos+1));for(let t=r.value;t<=s.value;t++)e.push(t);i=s.stopPos+3}}else if("或"===t[i])i++;else if("黑"===t[i])e.push("black"),i+=2;else if("白"===t[i])e.push("white"),i+=2;else if("红"===t[i])e.push("red"),i+=2;else if("蓝"===t[i])e.push("blue"),i+=2;else{if(!t[i].match(/[a-z]/i))break;e.push(t[i]),i+=1}}return e}specialRule(t){if("我"===t[0])return!0;if("如"===t[0]){const s=t.match(/^如果(?<ifCondition>(?<![,，]).*),那么(?<statement>.*)/).groups,e=s.ifCondition,i=s.statement;void 0!==e&&void 0!==i||alert(t+"不符合如果这条规则的规范");const r=[];this.parseLine(e,r,r);const o=[];this.parseLine(i,o,o);for(const t of r){const s={restrictAreas:t.restrictAreas,rules:{ifCondition:{condition:t.rules,statement:o}}};this.globalRules.push(s)}return!0}if("没"===t[0]){let s=t.substr(9);s=s.substr(0,s.length-1);for(let t=0;t<this.n*this.m;t++){if(this.filledArea[t])continue;const e=s.replace("<格子序号>",(t+1).toString());this.parseLine(e)}return!0}return"线"===t[0]&&(this.noMeet=!0,!0)}}class b{constructor(){this.possibleArray=[],this.connectedRules=[],this.globalRules=[],this.globalFinalRules=[],this.weight=[]}handleLoop(t,s){const e=new Set(t),i=this.globalRules,r=this.n,o=this.m;for(const n of t){let t=[...this.possibleArray[n]];const l=n/o,h=n%o,a=[n];0!=l&&e.has(n-o)?a.push(n-o):t=t.filter((t=>!t.includes("U"))),0!=h&&e.has(n-1)?a.push(n-1):t=t.filter((t=>!t.includes("L"))),l!=r-1&&e.has(n+o)?a.push(n+o):t=t.filter((t=>!t.includes("B"))),h!=o-1&&e.has(n+1)?a.push(n+1):t=t.filter((t=>!t.includes("R"))),this.possibleArray[n]=new Set(t);const u={restrictAreas:a,rules:{loop:s.rules.loop}};i.push(u)}s.rules.loop.areasSet=new Set(e)}async tryProcess(){const t=this.n,s=this.m;for(let e=0;e<t*s;e++){const t=this.possibleArray[e];if(t.size<=1)continue;const s=[];for(const i of t){this.possibleArray[e]=new Set([i]);const t=[],r=[];let o=!1;for(let s=0;s<this.connectedRules[e].length;s++){const i=this.relaxRule(this.globalRules[this.connectedRules[e][s]],t,this.connectedRules[e][s],r);if(this.resumePossible(t,r),-1===i){o=!0;break}}!1===o&&s.push(i)}this.possibleArray[e]=new Set(s)}return this.relax()}async solve(t,s,e,i){this.n=s,this.m=e,this.callback=i;const r=this.possibleArray,o=this.connectedRules,n=this.globalRules,l=this.globalFinalRules;new g(t,s,e,n,l);for(let t=0;t<s*e;t++)r.push(void 0),o.push([]),this.weight.push(0);n.descriptionRules=[],n.groupRules=[];const h=[];for(let t=0;t<n.length;t++){const s=n[t],{restrictAreas:e}=s,i=s.rules?s.rules.set:void 0;if(i){if(n.descriptionRules.push(t),s.rules.force){h.push(t);continue}if(s.rules.hashi)this.mergeSet(e[0],i);else for(let t=0;t<e.length;t++)this.mergeSet(e[t],i);if(s.rules.loop){this.handleLoop(e,s);continue}if(1==Object.keys(s.rules).length)continue}n.groupRules.push(t);for(let s=0;s<e.length;s++)o[e[s]].push(t),this.weight[e[s]]++}for(let t=0;t<l.length;t++){const s=l[t],{restrictAreas:e}=s;if(s.rules&&s.rules.largerThan)for(let t=0;t<e.length;t++)r[e[t]]=this.largerSet(r[e[t]],s.rules.largerThan);else if(s.rules&&s.rules.smallerThan)for(let t=0;t<e.length;t++)r[e[t]]=this.smallSet(r[e[t]],s.rules.smallerThan)}for(const t of h){const s=n[t],{restrictAreas:e}=s;for(let t=0;t<e.length;t++)this.possibleArray[e[t]]=new Set(s.rules.set)}this.hasLoop=!1;let a=this.relax();-1!=a&&this.hasLoop&&(a=await this.tryProcess()),$("#sudokuAnswer").html(""),-1!=a&&await this.dfs(),$("#sudokuAnswer").append("已找到所有解")}relaxDifference(t,s,e){let i=[];const r=new Map;for(let s=0;s<t.length;s++){const e=[...this.possibleArray[t[s]]];for(let t=0;t<e.length;t++){const s=r.get(e[t]);s?r.set(e[t],s+1):r.set(e[t],1)}}r.forEach(((i,r)=>{if(1===i)for(let i=0;i<t.length;i++){const o=t[i],n=this.possibleArray[o];if(n.size>1&&n.has(r)){s[o]||(s[o]=new Set(n)),this.possibleArray[o]=new Set([r]);for(const t of this.connectedRules[o])e.add(t)}}}));for(let s=0;s<t.length;s++)if(1===this.possibleArray[t[s]].size){const e=this.possibleArray[t[s]].values().next().value;if(i.includes(e))return-1;i.push(e)}for(let r=0;r<i.length;r++)for(let o=0;o<t.length;o++){const n=this.possibleArray[t[o]];if(n.size>1&&n.has(i[r])){if(s[t[o]]||(s[t[o]]=new Set(n)),n.delete(i[r]),0===n.size)return console.info("No"),-1;for(const s of this.connectedRules[t[o]])e.add(s);1===n.size&&i.push(n.values().next().value)}}i=[];for(let s=0;s<t.length;s++)if(1===this.possibleArray[t[s]].size){const e=this.possibleArray[t[s]].values().next().value;if(i.includes(e))return-1;i.push(e)}return 1}relaxSum(t,s,e,i){const r=i.rules.sum;let o,n=0,l=t.length,h=0,a=0,u=0;const c=[],f=[];for(let s=0;s<t.length;s++){const e=[...this.possibleArray[t[s]]];if(0===e.length)return-1;let i=e[0],r=e[0];for(const t of e)t>i&&(i=t),t<r&&(r=t);c[s]=i,f[s]=r,a+=i,u+=r,e.length>1?(h=t[s],o=void 0):(o=o?o+e[0]:e[0],l--,n+=e[0])}for(let i=0;i<t.length;i++){const n=this.possibleArray[t[i]],l=[];for(const t of n)(a+t-c[i]<r||u+t-f[i]>r)&&l.push(t);if(void 0!==o&&o!==r)return-1;if(a<r||u>r)return-1;if(l.length>0){s[t[i]]||(s[t[i]]=new Set(n));for(const s of this.connectedRules[t[i]])e.add(s);for(const t of l)n.delete(t)}}if(1===l){if(!this.possibleArray[h].has(r-n))return-1;s[h]||(s[h]=new Set(possibleList));for(const t of this.connectedRules[h])e.add(t);this.possibleArray[h]=new Set([r-n])}return 1}relaxCount(t,s,e,i){let r=0,o=!0,n=0;for(let s=0;s<t.length;s++){const i=this.possibleArray[t[s]];if(i.size<=0)return-1;i.has(e.item)&&n++,1===i.size?i.values().next().value===e.item&&r++:o=!1}if(e.set){const l=e.set[0];if(n<l)return-1;if(o&&r!==l)return-1;if(o||n!==l){if(!o&&r===l)for(let r=0;r<t.length;r++){const o=this.possibleArray[t[r]];if(o.length>1&&o.has(e.item)){s[t[r]]||(s[t[r]]=new Set(o)),o.delete(e.item);for(const s of this.connectedRules[t[r]])i.add(s)}}}else for(let r=0;r<t.length;r++){const o=this.possibleArray[t[r]];if(o.size>1&&o.has(e.item)){s[t[r]]||(s[t[r]]=this.possibleArray[t[r]]);for(const s of this.connectedRules[t[r]])i.add(s);this.possibleArray[t[r]]=new Set([e.item])}}}}relaxLinear(t,s,e,i){let r=0,o=0,n=0;s.length;const l=[],h=[];for(let e=0;e<s.length;e++){const i=this.possibleArray[s[e]];if(i.size<=0)return-1;if(i.size>1)return;r+=i.values().next().value*t.coefficient[e]}if(r!==t.result)return-1;for(let e=0;e<s.length;e++){const i=[...this.possibleArray[s[e]]];if(0===i.length)return-1;let r=i[0],a=i[0];for(const s of i){const i=s*t.coefficient[e];i>r&&(r=i),i<a&&(a=i)}l[e]=r,h[e]=a,o+=r,n+=a}return o<t.result||n>t.result?-1:void 0}isSatisfied(t,s){const e=[];for(const s of t){if(1!==this.possibleArray[s].size)return-1;e.push(this.possibleArray[s].values().next().value)}if(s.set){for(const t of e)if(!s.set.includes(t))return 0}else if(s.largerThan){for(const t of e)if(t<=s.largerThan)return 0}else if(s.smallerThan){for(const t of e)if(t>=s.smallerThan)return 0}else if(s.sum){let t=0;for(const s of e)t+=s;if(t!==s.sum)return 0}return 1}relaxIfCondition(t,s,e,i,r){if(1===this.isSatisfied(s,t.condition))for(const s of t.statement){const t=this.isSatisfied(s.restrictAreas,s.rules);if(0===t)return-1;if(-1===t){if(s.rules.sum){this.globalRules.push(s);const t=this.globalRules.length-1;r[t]=[];for(const e of s.restrictAreas)this.connectedRules[e].push(t),r[t].push(e)}for(const t of s.restrictAreas)if(1!==this.possibleArray[t].size){e[t]||(e[t]=new Set(this.possibleArray[t]));for(const s of this.connectedRules[t])i.add(s);s.rules.set?this.possibleArray[t]=new Set(s.rules.set):s.rules.largerThan?this.possibleArray[t]=this.largerSet(this.possibleArray[t],s.rules.largerThan):s.rules.smallerThan&&(this.possibleArray[t]=this.smallSet(this.possibleArray[t],s.rules.smallerThan))}}}}relaxWord(t,s,e){const i=[];for(const s of t)i.push(this.possibleArray[s]);const r=window.Trie.findAllByPossibleSets(i);if(console.info(r),!(r.length>=1e3))for(let o=0;o<t.length;o++){const n=new Set;for(const t of r)n.add(t[o]);if(new Set([...n].filter((t=>i[o].has(t)))).size!==this.possibleArray[t[o]].size){s[t[o]]||(s[t[o]]=new Set(this.possibleArray[t[o]]));for(const s of this.connectedRules[t[o]])e.add(s);this.possibleArray[t[o]]=new Set([...n].filter((t=>i[o].has(t))))}}}relaxBars(t,s,e,i){console.info(t,s,e,i);const r=[0],o=t.length,n=i.list.length;let l=0;const h=[],a=[],u=[],c=[];for(let t=0;t<=o;t++)h.push(!1),a.push(!1),c.push(!1);for(let s=0;s<t.length;s++){const e=t[s];this.possibleArray[e].has(i.item)&&(l++,1===this.possibleArray[e].size&&(c[s+1]=!0)),r.push(l)}const f=[[]],p=[[]];for(let t=0;t<=n;t++)f[0].push(!1),p[0].push(!1);p[0][0]=!0;for(let t=0;t<=n;t++)u.push(o+2);for(let t=1;t<=o;t++){f.push([!1]),c[t]?p.push([!1]):p.push([p[t-1][0]]);for(let s=1;s<=n;s++){let e=!1;t-i.list[s-1]>=0&&r[t]-r[t-i.list[s-1]]===i.list[s-1]&&(e=!0),e?t!=o&&!0===c[t+1]?f[t].push(!1):f[t].push(p[t-i.list[s-1]][s-1]):f[t].push(!1),c[t]?p[t].push(!1):p[t].push(p[t-1][s]||f[t-1][s])}}for(let t=n;t>=1;t--)for(let s=u[t]-2;s>=1;s--)if(f[s][t]){u[t-1]=s-i.list[t-1]+1;break}for(let t=o;t>=1;t--){t<u[0]&&!1===c[t]&&(h[t]=!0);for(let s=n;s>=1;s--){if(f[t][s]&&t<u[s]-1)for(let e=t;e>=t-i.list[s-1]+1;e--)a[e]=!0;p[t][s]&&t<u[s]&&!1===c[t]&&(h[t]=!0)}}for(let s=1;s<=o;s++){const e=this.possibleArray[t[s-1]];if(a[s]&&!h[s]&&!e.has(i.item))return-1;if(!a[s]&&h[s]&&e.has(i.item)&&1===e.size)return-1;if(!a[s]&&!h[s])return-1;if(!a[s]&&c[s])return-1}for(let r=1;r<=o;r++){if(a[r]&&!h[r]&&this.possibleArray[t[r-1]].size>1){s[t[r-1]]||(s[t[r-1]]=new Set(this.possibleArray[t[r-1]]));for(const s of this.connectedRules[t[r-1]])e.add(s);this.possibleArray[t[r-1]]=new Set([i.item])}if(!a[r]&&h[r]&&this.possibleArray[t[r-1]].has(i.item)){s[t[r-1]]||(s[t[r-1]]=new Set(this.possibleArray[t[r-1]]));for(const s of this.connectedRules[t[r-1]])e.add(s);this.possibleArray[t[r-1]].delete(i.item)}}}relaxPermutation(t,s,e,i){const r=Array.from(i.list),o=(t.length,[]),n=[];for(const s of t)if(1===this.possibleArray[s].size){const t=this.possibleArray[s].values().next().value;if("black"===t)continue;n.push(t)}else o.push(s);for(const t of n){let s=!1;for(let e=0;e<r.length;e++)if(t===r[e]){r.splice(e,1),s=!0;break}if(!s)return-1}const l=[];for(const t of n){let s=!1;for(let e=0;e<r.length;e++)if(t===r[e]){s=!0;break}s||l.push(t)}for(const t of o)for(const i of l)if(this.possibleArray[t].has(i)){s[t]||(s[t]=new Set(this.possibleArray[t]));for(const s of this.connectedRules[t])e.add(s);this.possibleArray[t]}}relaxLoop(t,s,e,i){const r={U:"B",L:"R",R:"L",B:"U"},o={U:0,B:1,L:2,R:3},n=["U","B","L","R"],l=[-this.m,this.m,-1,1],h=t[0];let a=[...this.possibleArray[h]];const u={};for(const t of a)2==t.length&&(u[t[0]]=(u[t[0]]||0)+1,u[t[1]]=(u[t[1]]||0)+1);const c=a.length,f=(t,s,e)=>{let i=t,n=e,h=0;for(;;){if(i==s)return h+1;if(!i||1!=this.possibleArray[i].size)return;const t=this.possibleArray[i].values().next().value.replace(n,"");i+=l[o[t]],n=r[t],h++}};let p=[],d=[];for(let e=0;e<4;e++){const o=n[e],c=l[e],f=h+c;if(-1==t.indexOf(h+c))continue;const g=r[o];let b=[...this.possibleArray[f]];if(u[o])if(u[o]===a.length){if(b.filter((t=>t.includes(g))).length<=0)return-1;if(b=b.filter((t=>t.includes(g))),this.possibleArray[f].size!=b.length){s[f]||(s[f]=new Set(this.possibleArray[f]));for(const t of this.connectedRules[f])i.add(t);this.possibleArray[f]=new Set(b)}}else b.filter((t=>t.includes(g))).length<=0&&p.push(o),0==b.filter((t=>!t.includes(g))).length&&d.push(o);else{if(b.filter((t=>!t.includes(g))).length<=0)return-1;if(b=b.filter((t=>!t.includes(g))),this.possibleArray[f].size!=b.length){s[f]||(s[f]=new Set(this.possibleArray[f]));for(const t of this.connectedRules[f])i.add(t);this.possibleArray[f]=new Set(b)}}}for(const t of p)a=a.filter((s=>!s.includes(t)));for(const t of d)a=a.filter((s=>s.includes(t)));if(1==e.number)for(let t=0;t<a.length;t++){const s=a[t];if("UR"==s||"UL"==s)continue;const i=h+l[o[s[0]]],n=h+l[o[s[1]]],u=[...this.possibleArray[i]].filter((t=>t.includes(r[s[0]]))),c=[...this.possibleArray[n]].filter((t=>t.includes(r[s[1]])));if(1!=u.length||1!=c.length)continue;const p=this.possibleArray[i];this.possibleArray[i]=new Set(u);const d=f(i,n,r[s[0]]);d&&d+1!=e.areasSet.size&&(a[t]=""),this.possibleArray[i]=p}if(a=a.filter((t=>""!=t)),c>a.length){s[h]||(s[h]=new Set(this.possibleArray[h]));for(const t of this.connectedRules[h])i.add(t);this.possibleArray[h]=new Set(a)}}relaxHashi(t,s,e,i){const r=["u","d","l","r"],o={u:"d",d:"u",l:"r",r:"l"},n=e.to,l=this.possibleArray[t[0]],h=(t,s)=>new Set(s.filter((s=>t.includes(s)))),a=(t,s)=>{const e=[];for(const i of t)e.push(i.hashi[s]);return e};for(const e of r){const r=n[e];if(!r)continue;const u=[...this.possibleArray[r]],c=o[e],f=h(a(l,e),a(u,c));for(const r of l)if(!f.has(r.hashi[e])){s[t[0]]||(s[t[0]]=new Set(this.possibleArray[t[0]]));for(const s of this.connectedRules[t[0]])i.add(s);this.possibleArray[t[0]].delete(r)}for(const t of u)if(!f.has(t.hashi[c])){s[r]||(s[r]=new Set(this.possibleArray[r]));for(const t of this.connectedRules[r])i.add(t);this.possibleArray[r].delete(t)}}if(e.conflict){if(e.conflict.d){const i=e.conflict.d.rules;let r=!1;if(i)for(const t of i)if(0===[...this.possibleArray[t.to.self]].filter((t=>!t.hashi.r)).length){r=!0;break}if(r){const e=[...this.possibleArray[t[0]]].filter((t=>!t.hashi.d));if(0===e.length)return-1;e.length<this.possibleArray[t[0]].size&&(s[t[0]]||(s[t[0]]=new Set(this.possibleArray[t[0]])),this.possibleArray[t[0]]=new Set(e))}}if(e.conflict.r){const i=e.conflict.r.rules;let r=!1;if(i)for(const t of i)if(0===[...this.possibleArray[t.to.self]].filter((t=>!t.hashi.d)).length){r=!0;break}if(r){const e=[...this.possibleArray[t[0]]].filter((t=>!t.hashi.r));if(0===e.length)return-1;e.length<this.possibleArray[t[0]].size&&(s[t[0]]||(s[t[0]]=new Set(this.possibleArray[t[0]])),this.possibleArray[t[0]]=new Set(e))}}}}relaxRule(t,s,e,i){const r=new Set([]),o=t.restrictAreas;if(t.rules.isDifferent){if(-1===this.relaxDifference(o,s,r))return-1}else if(t.rules.sum){if(-1===this.relaxSum(o,s,r,t))return-1}else if(t.rules.count){if(-1===this.relaxCount(o,s,t.rules.count,r))return-1}else if(t.rules.linear){if(-1===this.relaxLinear(t.rules.linear,o,s,r))return-1}else if(t.rules.ifCondition){if(-1===this.relaxIfCondition(t.rules.ifCondition,o,s,r,i))return-1}else if(t.rules.isWord){if(-1===this.relaxWord(o,s,r))return-1}else if(t.rules.bars){if(-1===this.relaxBars(o,s,r,t.rules.bars))return-1}else if(t.rules.permutation){if(-1===this.relaxPermutation(o,s,r,t.rules.permutation))return-1}else if(t.rules.loop){if(-1===this.relaxLoop(o,s,t.rules.loop,r))return-1;this.hasLoop=!0}else if(t.rules.hashi&&-1===this.relaxHashi(o,s,t.rules.hashi,r))return-1;for(const t of r)if(e!==t&&-1===this.relaxRule(this.globalRules[t],s,t,i))return-1;return 1}print(){const t=[];let s="",e=[];$(".vertical-").remove(),$(".horizon-").remove();for(let i=0;i<this.possibleArray.length;i++){const r=this.possibleArray[i];if(!r||1!=r.size)continue;const o=r?r.values().next().value:" ";if(o.hashi){const t=o.to.r,s=o.hashi.r,e=o.to.d,r=o.hashi.d;if(s){let e=i+1;$(`.sudoku-grid #grid-${e}`).html("");const r=100/(s+1);for(;e!=t;){for(let t=0;t<s;t++)$(`.sudoku-grid #grid-${e}`).append(`<div class="horizon-" style="top:${r*(t+1)}%"></div>`);e++}}if(r){let t=i+this.m;$(`.sudoku-grid #grid-${t}`).html("");const s=100/(r+1);for(;t!=e;){for(let e=0;e<r;e++)$(`.sudoku-grid #grid-${t}`).append(`<div class="vertical-" style="left:${s*(e+1)}%"></div>`);t+=this.m}}}else"black"===o?($(`.sudoku-grid #grid-${i}`).css("background-color",o),$(`.sudoku-grid #grid-${i}`).css("color","white")):"white"===o?($(`.sudoku-grid #grid-${i}`).css("background-color",o),$(`.sudoku-grid #grid-${i}`).css("color","black")):2==o.length?($(`.sudoku-grid #grid-${i}`).attr("class","sudoku-grid-content "+o),$(`.sudoku-grid #grid-${i}`).css("color","white")):$(`.sudoku-grid #grid-${i}`).css("background-color",o);e.push(o),s+=o+" ",i%this.m==this.m-1&&(t.push(e),s+="\n",e=[])}$("#sudokuAnswer").append(s+"\n-----------------------\n")}relax(){for(let t=0;t<this.globalRules.groupRules.length;t++){const s=this.globalRules[this.globalRules.groupRules[t]],e=this.relaxRule(s,[],this.globalRules.groupRules[t],[]);if(-1==e)return e}}mergeSet(t,s){var e;void 0===this.possibleArray[t]?this.possibleArray[t]=new Set(s):this.possibleArray[t]=(e=this.possibleArray[t],new Set(s.filter((t=>e.has(t)))))}getSmallestGrid(){let t=-1,s=1024,e=0;for(let i=0;i<this.possibleArray.length;i++){const r=this.possibleArray[i]?this.possibleArray[i].size:1,o=this.weight[i];if(1!==r&&((r<s||r==s&&o>e)&&(e=o,s=r,t=i),2===s&&0!=o))return t}return t}async dfs(){const t=this.getSmallestGrid();if(-1===t)return this.print(),await this.callback(),confirm("发现了一个解，是否继续寻找下一个解?(可能耗时很久)")?0:-1;const s=this.possibleArray[t];for(const e of s.values()){const s=[],i=[];if(s[t]=new Set(this.possibleArray[t]),this.possibleArray[t]=new Set([e]),this.connectedRules[t]){let e=!1;for(let r=0;r<this.connectedRules[t].length;r++)if(-1===this.relaxRule(this.globalRules[this.connectedRules[t][r]],s,this.connectedRules[t][r],i)){this.resumePossible(s,i),e=!0;break}if(!0===e)continue}const r=await this.dfs();if(-1===r)return r;this.resumePossible(s,i)}this.possibleArray[t]=s}resumePossible(t,s){t.forEach(((t,s)=>{this.possibleArray[s]=t})),s.forEach(((t,s)=>{for(const s of t)this.connectedRules[s].pop();this.globalRules.pop()}))}largerSet(t,s){const e=new Set([]);for(const i of t)i>s&&e.add(i);return e}smallSet(t,s){const e=new Set([]);for(const i of t)i<s&&e.add(i);return e}}})(),__webpack_exports__})()}));