!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.Solver=e():t.Solver=e()}(this,(()=>(()=>{"use strict";var __webpack_modules__={895:(t,e,s)=>{s.d(e,{B:()=>r});class i{constructor(){this.isWord=!1}}class r{constructor(){this.root=new i}insert(t){if(!t)return;let e=this.root;for(let s=0;s<t.length;s++)e[t[s]]||(e[t[s]]=new i),e=e[t[s]];e.isWord=!0}contains(t){let e=this.root;for(let s=0;s<t.length;s++){if(!e[t[s]])return!1;e=e[t[s]]}return e.isWord}findAll(t){const e=[];let s=this.root,i="";for(let r=0;r<t.length;r++){const o=s[t[r]];if(i+=t[r],!o)break;o.isWord&&e.push(i),s=o}return e}dfs(t,e,s,i,r){if(e===t.length)return void(s.isWord&&r.push(i));const o=t[e];for(let n=0;n<o.length;n++){const l=o[n],h=s[l];h&&this.dfs(t,e+1,h,i+l,r)}}findAllByPossibleSets(t){const e=[];for(let s=0;s<t.length;s++){const i=t[s];e.push([...new Set(i)])}const s=[];return this.dfs(e,0,this.root,"",s),s}}},481:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{l:()=>OneWord});var _common_Trie__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(895);class OneWord{constructor(){this.initTrie()}initTrie(){const t=window.words;if(!window.Trie&&t){window.Trie=new _common_Trie__WEBPACK_IMPORTED_MODULE_0__.B;for(let e in t)if(e)for(let s of t[e])window.Trie.insert(s)}this.Trie=window.Trie}editDistance(t,e){if(t===e)return 0;var s=t.length,i=e.length;if(s&&i){for(var r,o,n,l,h=0,a=0,u=[];h<s;)u[h]=++h;for(;a<i;)for(l=e.charCodeAt(a),r=a,o=++a,h=0;h<s;++h)n=r+(t.charCodeAt(h)===l?0:1),o=o<(r=u[h])?o<n?o+1:n:r<n?r+1:n,u[h]=o;return o}return s+i}async findByRegularExpression(str,callback,filter){const words=window.words,regularExpression=eval(`/${str}/`),answer=[];callback||(callback=()=>{});for(let t in words){if(!t)continue;const e=t.length;for(let s=0;s<words[t].length;s++){const i=words[t][s];regularExpression.test(i)&&(answer.push(i),await callback(e,i))}}return answer}async findByWildcard(wildcard,callback,filter,moreWord){let regx="";const isLowerCase=t=>t>="a"&&t<="z",parseWildcard=(t,e)=>{const s=[];let i="";const r=t.length;let o="";const n=[];let l=0;for(let h=0;h<r;h++){let a=t[h];if("*"==a)o=e?".*"+o:o+".*",i+=".*";else if(e||"["!=a)if(e&&"]"==a){h++;let s="[";for(;h<r&&"["!=t[h];)s+=t[h],h++;s+="]",o=e?s+o:o+s}else isLowerCase(a)?(o=e?a+o:o+a,i+=a):(o=e?"."+o:o+".","#"==a?i+=".":n[a]?i+=n[a]:(i+="(.)",n[a]="\\"+ ++l));else{h++;let s="[";for(;h<r&&"]"!=t[h];)s+=t[h],h++;s+="]",i+=s,o=e?s+o:o+s}e||"*"!=t[h+1]?s.push(o):s.push(o+".*")}return i=`^${i}$`,{wildcardObj:s,whole:i}},ww=parseWildcard(wildcard);if(moreWord){const whole=eval(`/${ww.whole}/`),wildcardsRev=parseWildcard(wildcard.split("").reverse().join(""),!0).wildcardObj,wildcards=ww.wildcardObj;console.info(wildcards);const answers=[],answerRev=[];for(const t of wildcards)answers.push(await this.findByRegularExpression(`^${t}$`,(()=>{}),filter));for(const t of wildcardsRev)answerRev.push(await this.findByRegularExpression(`^${t}$`,(()=>{}),filter));const answerFinal=[];let count=0;for(let t=0;t<answers.length-1;t++)for(let e=0;e<answers[t].length;e++){const s=answerRev[answers.length-t-2];for(let i=0;i<s.length;i++){const r=answers[t][e]+" "+s[i],o=answers[t][e]+s[i];if(whole.test(o)){if(count++,count>2e4)return await callback(20,"个数超过两万个，停止计算"),answerFinal;await callback(r.length-1,r),answerFinal.push(r)}}}return answerFinal}return this.findByRegularExpression(`^${ww.whole}$`,callback,filter)}isFilter(t,e,s){return!!window.c&&!!window.c[t]&&(0==(16&s)&&0==(16&window.c[t][e])||0==(s&window.c[t][e]))}makeLetterSet(t){const e=[];for(let s=0;s<t.length;s++)e[t[s]]||(e[t[s]]=0),e[t[s]]++;return e}async onlyContains(t,e){const s=window.words,i=[],r=this.makeLetterSet(t),o=(t,e)=>{const s=[];for(let i=0;i<e.length;i++){if(!t[e[i]])return!1;s[e[i]]||(s[e[i]]=0),s[e[i]]++}return!0};for(let t in s){if(!t)continue;const n=t.length;for(let l of s[t])o(r,l)&&(await e(n,l),i.push(l))}return i}permutation(t){const e=window.words,s=[],i=this.makeLetterSet(t),r=(t,e)=>{const s=[];for(let i=0;i<e.length;i++){if(!t[e[i]])return!1;s[e[i]]||(s[e[i]]=0),s[e[i]]++}for(let e in t)if(!s[e]||t[e]!=s[e])return!1;return!0};for(let t in e)if(t)for(let o of e[t])r(i,o)&&(console.info(o),s.push(o));return s}stringInclude(t,e){const s=[];for(let i=0;i<e.length;i++)t[e[i]]&&(s[e[i]]||(s[e[i]]=0),s[e[i]]++);for(let e in t)if(!s[e]||t[e]>s[e])return!1;return!0}async contains(t,e){const s=window.words,i=[];e||(e=()=>{});const r=(t,e)=>{const s=[];for(let i=0;i<e.length;i++){if(!t[e[i]])return!1;s[e[i]]||(s[e[i]]=0),s[e[i]]++}return!0},o=this.makeLetterSet(t);for(let t in s){if(!t)continue;const n=t.length;for(let l of s[t])(this.stringInclude(o,l)||r(o,l))&&(i.push(l),await e(n,l))}return i}async findSimilarity(t,e,s){const i=window.words,r=[];e||(e=1),s||(s=()=>{});const o=t.length;for(let n in i){if(!n)continue;const l=n.length;if(!(Math.abs(l-o)>e))for(let o of i[n])this.editDistance(t,o)<=e&&(r.push(o),await s(l,o))}return r}async findByCode(t,e){const s=window.words,i=[];e||(e=()=>{});const r={isWord:t=>this.Trie.contains(t),anagram:(t,e)=>{const s=this.makeLetterSet(e);return this.stringInclude(s,t)}};try{var o=new Function(`return ${t}`)();if(!o)throw new Error("没有函数")}catch(t){throw alert(`程序错误，请仔细检查你的代码\n错误信息:\n${t.message}`),t}for(let t in s)if(t)for(let n of s[t]){let t;try{t=o(n,r)}catch(t){continue}t&&(i.push(t),await e(t.length,t))}console.info(t)}}}},__webpack_module_cache__={};function __webpack_require__(t){var e=__webpack_module_cache__[t];if(void 0!==e)return e.exports;var s=__webpack_module_cache__[t]={exports:{}};return __webpack_modules__[t](s,s.exports,__webpack_require__),s.exports}__webpack_require__.d=(t,e)=>{for(var s in e)__webpack_require__.o(e,s)&&!__webpack_require__.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},__webpack_require__.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),__webpack_require__.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var __webpack_exports__={};return(()=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{OneWord:()=>r.l,RubikCubeStage:()=>p,SubstitutionSolver:()=>i,SudokuSolver:()=>b,WordSearch:()=>l});class t{constructor(){this.mode=t.impossible,this.matrix=new Array(26),this.ensure=new Array(26);for(let e=0;e<26;e++){this.matrix[String.fromCharCode(97+e)]=new Array(26);let s=this.matrix[String.fromCharCode(97+e)];for(let e=0;e<26;e++)s[String.fromCharCode(97+e)]=t.possible}}init(){this.matrix=new Array(26),this.ensure=new Array(26);for(let e=0;e<26;e++){this.matrix[String.fromCharCode(97+e)]=new Array(26);let s=this.matrix[String.fromCharCode(97+e)];for(let e=0;e<26;e++)s[String.fromCharCode(97+e)]=t.possible}this.mode=t.impossible}disallow(t,e){const s=this.matrix[t][e]!==this.mode;return this.matrix[t][e]=this.mode,s}unique(e){let s=0;for(let i=0;i<26;i++)if(this.matrix[e][String.fromCharCode(97+i)]===t.possible&&(this.ensure[e]=String.fromCharCode(97+i),s++,s>1))return this.ensure[e]=null,!1;return!0}getAllowedChars(e){const s=new Array;for(let i=0;i<26;i++)this.matrix[e][String.fromCharCode(97+j)]!==t.impossible&&s.push(String.fromCharCode(97+j));return s}isAllowed(t,e){return this.matrix[t][e]}mapMode(t){this.mode=t}copy(){const e=new t;e.ensure=[].concat(this.ensure);for(let t=0;t<26;t++)for(let s=0;s<26;s++)e.matrix[String.fromCharCode(97+t)][String.fromCharCode(97+s)]=this.matrix[String.fromCharCode(97+t)][String.fromCharCode(97+s)];return e}}t.guessPossible=3,t.guessImpossible=2,t.possible=1,t.impossible=0;class e{constructor(t,e,s){this.word=t,this.possibleList=JSON.parse(JSON.stringify(e)),this.position=s}eliminate(e){for(var s=this.word.length,i=this.possibleList.length,r=new Array,o=!1,n=0;n<i;n++){var l=this.possibleList[n];if(void 0!==l){for(var h=0;h<s;h++)if(e.isAllowed(this.word[h],l[h])===t.impossible){r[n]=1,o=!0;break}}else r[n]=1}for(n=i-1;n>=0;n--)1===r[n]&&this.possibleList.splice(n,1);return o}trimMappingTable(e){for(var s=this.word.length,i=this.possibleList.length,r=new Array(26),o=!1,n=0;n<s;n++){for(var l=0;l<26;l++)r[l]=t.impossible;var h=this.word[n];for(l=0;l<i;l++)r[this.possibleList[l].charCodeAt(n)-97]=t.possible;for(l=0;l<26;l++)if(r[l]!==t.possible){const t=e.disallow(this.word[n],String.fromCharCode(97+l));o=o||t}if(!0===e.unique(h)){const t=e.ensure[h];for(l=0;l<26;l++)h!==String.fromCharCode(l+97)&&(o=e.disallow(String.fromCharCode(97+l),t)||o)}}return o}customize(t){let e=this.eliminate(t),s=this.trimMappingTable(t);return e||s}copy(){return new e(this.word,this.possibleList,this.position)}}class s{constructor(){this._list=[]}pattern(t){for(var e=0,s=t.length,i="",r=new Array(26),o=0;o<s;o++)null==r[t[o]]&&(r[t[o]]=String.fromCharCode(e+97),e++),i+=r[t[o]];return i}generateWeight(t,e){const s=t.length;if(s>10)for(let i=0;i<s;i++)e[t[i]]=s>100&&i<=10?17:i/s<.4?15:i/s<.6?8:i/s<.9?1:-1;else for(let i=0;i<s;i++)e[t[i]]=s-i}build(t,s,i,r){const o=window.words,n=t.length;for(let l=0;l<n;l++)if(""!=t[l])if(t[l].includes("'")){const s=t[l].split("'");if(s[1]&&1===s[1].length){const t=new e(s[1],["s","t","d"],l);this._list.push(t)}}else{const n=o[this.pattern(t[l])].slice(0);this.generateWeight(n,r);const h=new e(t[l],n,l);h.customize(i),h.possibleList.length>1?this._list.push(h):s.list[h.position]=h}}set list(t){this._list=t}get list(){return this._list}push(t){this._list.push(t)}copy(){const t=new s;for(let e=0;e<this._list.length;e++){const s=this._list[e];s&&(t.list[e]=s.copy())}return t}getMinPossibleList(){var t=this._list[0].possibleList.length,e=0;for(let s=0;s<this._list.length;s++)t>this._list[s].possibleList.length&&(t=this._list[s].possibleList.length,e=s);return e}refreshByMappintTable(t,e){var s=0;const i=this._list;let r=0;for(;i.length>0;){var o=i.shift();const n=o.customize(e);if(o.possibleList.length>1)i.push(o);else{if(0===o.possibleList.length)return!1;t.list[o.position]=o}if(++s-r>i.length)break;n&&(r=s)}return!0}refreshByMappintTable2(t,e){let s=this._list;for(;;){let r=!1,o=[];for(let n=0;n<s.length;n++){var i=s[n];if(r=i.customize(e)||r,i.possibleList.length>1)o.push(i);else{if(0===i.possibleList.length)return this._list=s,!1;t.list[i.position]=i}}if(s=o,!1===r)break}return this._list=s,!0}empty(){return 0===this._list.length}setPossibleList(t,e){this._list[t].possibleList=[],this._list[t].possibleList.push(e)}}class i{constructor(){this.globleAns=[],this.ans=new Array,this.weight=[],this.threshold=10}substituteSolver(e,i,r){this.threshold=r||10,this.maxOutput=i||3e3;var o=(e=e.toLowerCase()).split(/[^a-zA-Z\']+/),n=new t,l=new s;this.globleAns=[],this.ans=[];var h=new s;return l.build(o,h,n,this.weight),l.refreshByMappintTable(h,n),this.dfsNonRecursion(l,h,n),this.globleAns.sort(((t,e)=>e.weight-t.weight)),console.info(this.globleAns),this.globleAns.map((t=>t.ret))}output(t){let e="",s=0;for(let i of t.list)e+=i.possibleList[0]+" ",s+=this.weight[i.possibleList[0]];this.globleAns.push({ret:e,weight:s})}dfs(t,e,s){if(t.empty())return void this.output(e);const i=t.getMinPossibleList(),r=t.list[i].possibleList.length;for(var o=0;o<r;o++){const r=t.list[i].possibleList[o],n=t.copy(),l=e.copy(),h=s.copy();n.setPossibleList(i,r),!1!==n.refreshByMappintTable(l,h)&&this.dfs(n,l,h)}}dfsNonRecursion(t,e,s){let i=new Array;i.push({unknownWordsList:t,knownWordsList:e,mappingTable:s});let r=0,o=new Array;for(;i.length>0||o.length>0;){for(;i.length>0;){const t=i.pop();if(t.unknownWordsList.empty()){if(this.output(t.knownWordsList),r++,r>this.maxOutput)return;continue}const e=t.unknownWordsList.getMinPossibleList(),s=t.unknownWordsList.list[e].possibleList.length,l=Math.min(s,this.threshold);for(var n=0;n<l;n++){const s=t.unknownWordsList.list[e].possibleList[n],r=t.unknownWordsList.copy(),o=t.knownWordsList.copy(),l=t.mappingTable.copy();r.setPossibleList(e,s),!1!==r.refreshByMappintTable(o,l)&&i.push({unknownWordsList:r,knownWordsList:o,mappingTable:l})}t.unknownWordsList.list[e].possibleList=t.unknownWordsList.list[e].possibleList.slice(l),!1!==t.unknownWordsList.refreshByMappintTable(t.knownWordsList,t.mappingTable)&&o.push({unknownWordsList:t.unknownWordsList,knownWordsList:t.knownWordsList,mappingTable:t.mappingTable})}i=o,o=new Array}}}var r=__webpack_require__(481),o=__webpack_require__(895);class l{constructor(){}customWordList(t){this.customTrie=new o.B;for(let e of t)this.Trie.contains(e)||customTrie.insert(e)}contains(t){let e=this.root;for(let s=0;s<t.length;s++){if(!e[t[s]])return!1;e=e[t[s]]}return e.isWord}search(t,e,s,i,r){let o=t,n=e,l="";for(;o<this.row&&o>=0&&n<this.column&&n>=0;)l+=this.matrix[o][n],o+=s,n+=i;return window.Trie.findAll(l).filter((t=>t.length>=2)).map((r=>({word:r,x:t,y:e,dx:s,dy:i})))}wordSearch(t,e){e||(e={length:3});const s=[-1,0,1,-1,1,-1,0,1],i=[1,1,1,0,0,-1,-1,-1];this.matrix=t;const r=[],o=this.row=t.length,n=this.column=t[0].length;for(let t=0;t<o;t++)for(let o=0;o<n;o++)for(let n=0;n<8;n++){const l=this.search(t,o,s[n],i[n],e);for(let t of l)r.push(t)}return r}buildMatrix(t,e,s){let i=t.replace(/[^A-Za-z\n]/g,"").toLowerCase();const r=[];if(!(e=0)||!s){const t=i.split("\n");i=i.replace(/[\n]/g,"");for(let i of t)i&&(s=i.length,e++)}let o=0;for(let t=0;t<e;t++){r.push([]);for(let e=0;e<s;e++){if(!i[o])throw new Error("StringTooShort");r[t].push(i[o]),o++}}if(o<i.length)throw new Error("StringTooLong");return r}}class h{constructor(t,e,s){this.angleX=0,this.angleY=0,this.angleZ=0,this.originX=t,this.originY=e,this.originZ=s,this.x=t,this.y=e,this.z=s,this.mat=[[1,0,0],[0,1,0],[0,0,1]]}multiply(t,e){const s=[[0,0,0],[0,0,0],[0,0,0]];for(let i=0;i<3;i++)for(let r=0;r<3;r++)for(let o=0;o<3;o++)s[i][r]+=t[i][o]*e[o][r];return s}rotateHelp(t,e){let s=this.originX,i=this.originY,r=this.originZ;switch(e){case"x":i=this.originY*Math.cos(t)-this.originZ*Math.sin(t),r=this.originY*Math.sin(t)+this.originZ*Math.cos(t);break;case"y":s=this.originX*Math.cos(t)+this.originZ*Math.sin(t),r=-this.originX*Math.sin(t)+this.originZ*Math.cos(t);break;case"z":s=this.originX*Math.cos(t)-this.originY*Math.sin(t),i=this.originX*Math.sin(t)+this.originY*Math.cos(t)}this.originX=s,this.originY=i,this.originZ=r}rotate(t,e,s){const i=[[1,0,0],[0,1,0],[0,0,1]],r=t*Math.PI/180;if(!0===s)this.rotateHelp(r,e);else switch(e){case"x":i[1][1]=Math.cos(r),i[1][2]=-Math.sin(r),i[2][1]=Math.sin(r),i[2][2]=Math.cos(r),this.angleX+=t;break;case"y":i[0][0]=Math.cos(r),i[2][0]=-Math.sin(r),i[0][2]=Math.sin(r),i[2][2]=Math.cos(r),this.angleY+=t;break;case"z":i[0][0]=Math.cos(r),i[0][1]=-Math.sin(r),i[1][0]=Math.sin(r),i[1][1]=Math.cos(r),this.angleZ+=t}this.mat=this.multiply(this.mat,i);const o=this.originX*this.mat[0][0]+this.originY*this.mat[0][1]+this.originZ*this.mat[0][2],n=this.originX*this.mat[1][0]+this.originY*this.mat[1][1]+this.originZ*this.mat[1][2],l=this.originX*this.mat[2][0]+this.originY*this.mat[2][1]+this.originZ*this.mat[2][2];this.x=o,this.y=n,this.z=l}resetRotation(){this.mat=[[1,0,0],[0,1,0],[0,0,1]],this.rotate("x",0)}}class a{constructor(t,e,s,i,r,o,n){this.points=[t,e,s,i],this.len=r,o||(o="red"),this.color=o,this.index=n}render(t,e,s){const i=new h(this.points[1].x-this.points[0].x,this.points[1].y-this.points[0].y,this.points[1].z-this.points[0].z),r=new h(this.points[3].x-this.points[0].x,this.points[3].y-this.points[0].y,this.points[3].z-this.points[0].z);if(new h(i.y*r.z-r.y*i.z,i.z*r.x-r.z*i.x,i.x*r.y-r.x*i.y).x<=0)return;const o=150,n=new h(this.points[0].y+o,this.points[0].z+o),l=new h(this.points[1].y+o,this.points[1].z+o),a=(new h(this.points[2].y+o,this.points[2].z+o),new h(this.points[3].y+o,this.points[3].z+o));t.beginPath(),t.moveTo(this.points[0].y+o,this.points[0].z+o),t.lineTo(this.points[1].y+o,this.points[1].z+o),t.lineTo(this.points[2].y+o,this.points[2].z+o),t.lineTo(this.points[3].y+o,this.points[3].z+o),t.lineTo(this.points[0].y+o,this.points[0].z+o),t.lineWidth=1,t.stroke();let u=Math.sqrt((n.x-a.x)*(n.x-a.x)+(n.y-a.y)*(n.y-a.y))/this.len;u=(n.y-a.y)/this.len;let c=-(l.x-n.x)/this.len,f=(l.y-n.y)/(l.x-n.x),p=(a.x-n.x)/(a.y-n.y);Math.abs(a.y-n.y)<1e-7&&(p=0),t.setTransform(c,f*c,p*u,u,this.points[3].y+o,this.points[3].z+o),t.fillStyle=this.color,s?t.drawImage(s,-this.len,0,this.len,this.len):t.fillRect(-this.len,0,this.len,this.len),t.setTransform(1,0,0,1,0,0)}}class u{constructor(t,e,s,i){this.index=i,s||(s=[]);const r=[];for(let s=0;s<8;s++)r.push(new h(t.x+(1&s)*e,t.y+(s>>1&1)*e,t.z+(s>>2&1)*e));const o=[[2,0,1,3],[5,7,3,1],[4,6,7,5],[6,4,0,2],[7,6,2,3],[4,5,1,0]];this.faces=[];const n=o.length,l=[];let u=0;for(let t=0;t<n;t++){if(null===s[t])continue;l[o[t][0]]=!0,l[o[t][1]]=!0,l[o[t][2]]=!0,l[o[t][3]]=!0;const i=new a(r[o[t][0]],r[o[t][1]],r[o[t][2]],r[o[t][3]],e,s[t],u++);this.faces.push(i)}this.points=[];for(let t=0;t<8;t++)!0===l[t]&&this.points.push(r[t])}render(t,e){for(let s of this.faces){let i=e?e[s.index]:null;s.render(t,this.index,i)}}rotate(t,e,s){for(let i of this.points)i.rotate(t,e,s)}resetRotation(){for(let t of this.points)t.resetRotation()}}class c{ontheEdge(t){return 0===t||t===this.degree-1}constructor(t,e,s,i){s||(s=3),this.degree=s,this.blockSize=e/s,this.materials=i,this.cubes=[];const r=["white","orange","yellow","red","blue","green"];let o=0;for(let e=0;e<s;e++)for(let i=0;i<s;i++)for(let n=0;n<s;n++){if(!this.ontheEdge(e)&&!this.ontheEdge(i)&&!this.ontheEdge(n))continue;const l=new h(t.x+e*this.blockSize,t.y+i*this.blockSize,t.z+n*this.blockSize),a=r.slice(0);0!=n&&(a[0]=null),n!=s-1&&(a[2]=null),e!=s-1&&(a[1]=null),0!=e&&(a[3]=null),i!=s-1&&(a[4]=null),0!=i&&(a[5]=null);const c=new u(l,this.blockSize,a,o++);this.cubes.push(c)}}render(t){const e=this.cubes.slice(0);e.sort(((t,e)=>e.points[0].x-t.points[0].x));for(let s of e){const e=this.materials?this.materials[s.index]:null;s.render(t,e)}}rotate(t,e){for(let s of this.cubes)s.rotate(t,e)}resetRotation(){for(let t of this.cubes)t.resetRotation()}permutation(t,e){for(let s of t){const t=s.length;if(1===e)for(let e=0;e<t-1;e++){const t=this.cubes[s[e]];this.cubes[s[e]]=this.cubes[s[e+1]],this.cubes[s[e+1]]=t}else for(let e=t-1;e>=1;e--){const t=this.cubes[s[e]];this.cubes[s[e]]=this.cubes[s[e-1]],this.cubes[s[e-1]]=t}}}rotateLayer(t,e,s){for(let i of t){const t=i.length;for(let r=0;r<t;r++)this.cubes[i[r]].rotate(90*e,s,!0)}}front(t){const e=[[2,8,6,0],[1,5,7,3],[4]];this.rotateLayer(e,t,"x"),this.permutation(e,t)}up(t){const e=[[0,6,23,17],[3,14,20,9],[12]];this.rotateLayer(e,t,"z"),this.permutation(e,t)}back(t){const e=[[22,24,20,18],[19,25,23,17],[21]];this.rotateLayer(e,t,"x"),this.permutation(e,t)}bottom(t){const e=[[11,5,16,22],[19,2,8,25],[13]];this.rotateLayer(e,t,"z"),this.permutation(e,t)}left(t){const e=[[0,17,19,2],[1,9,18,11],[10]];this.rotateLayer(e,t,"y"),this.permutation(e,t)}right(t){const e=[[8,6,23,25],[16,7,14,24],[15]];this.rotateLayer(e,t,"y"),this.permutation(e,t)}}class f{constructor(t){this.objList=[],this.ctx=t}add(t){this.objList.push(t)}render(){for(let t of this.objList)t.render(this.ctx)}}class p{constructor(t,e,s,i){this.ctx=t,this.width=e,this.height=s,this.rotationAngle={x:20,y:20,z:20};const r=this.makeMaterials(i);this.cube=new c(new h(-75,-75,-75),150,3,r),this.rotate(this.rotationAngle),this.draw(this.rotationAngle),this.register()}makeMaterials(t){const e=[{index:0,arr:[6,18,11]},{index:1,arr:[21,14]},{index:2,arr:[36,24,17]},{index:3,arr:[7,19]},{index:4,arr:[22]},{index:5,arr:[37,25]},{index:6,arr:[8,20,27]},{index:7,arr:[23,30]},{index:8,arr:[38,26,33]},{index:9,arr:[3,10]},{index:10,arr:[13]},{index:11,arr:[39,16]},{index:12,arr:[4]},{index:13,arr:[40]},{index:14,arr:[5,28]},{index:15,arr:[31]},{index:16,arr:[41,34]},{index:17,arr:[0,51,9]},{index:18,arr:[48,12]},{index:19,arr:[45,42,15]},{index:20,arr:[1,52]},{index:21,arr:[49]},{index:22,arr:[46,43]},{index:23,arr:[2,53,29]},{index:24,arr:[50,32]},{index:25,arr:[47,44,35]}],s=[];for(let i of e){s[i.index]=[];for(let e of i.arr)s[i.index].push(t[e])}return s}rotate(t){this.rotationAngle={x:this.rotationAngle.x+t.x,y:this.rotationAngle.y+t.y,z:this.rotationAngle.z+t.z};const e=this.cube;e.rotate(t.x,"x"),e.rotate(t.y,"y"),e.rotate(t.z,"z")}draw(){const t=this.cube;this.ctx.clearRect(0,0,this.width,this.height);const e=new f(this.ctx);e.add(t),e.render()}resetRotation(){this.cube.resetRotation()}front(t){t||(t=1),this.cube.front(t),this.draw()}up(t){t||(t=1),this.cube.up(t),this.draw()}back(t){t||(t=1),this.cube.back(t),this.draw()}bottom(t){t||(t=1),this.cube.bottom(t),this.draw()}left(t){t||(t=1),this.cube.left(t),this.draw()}right(t){t||(t=1),this.cube.right(t),this.draw()}register(){const t=this;let e={},s=!1;$("#rubik-cube").off("mousedown"),$("#rubik-cube").off("touchstart"),$("#rubik-cube").off("touchend"),$("#rubik-cube").off("touchmove"),$(".cube-block").off("mousedown"),$("body").off("mouseup"),$("body").off("mousemove"),$(window).off("mouseup"),$("#rubik-cube").mousedown((t=>{if(1===t.which){var i=t.pageX,r=t.pageY;!1===s&&(e.x=i,e.y=r),s=!0}})),$("body").mouseup((e=>{if(!0===s){s=!1,t.resetRotation();const e={x:20,y:20,z:20};t.rotate(e),t.draw()}})),$("body").mousemove((i=>{if(!0===s){const s={x:0,y:0,z:0};let r=i.pageX,o=i.pageY,n=r-e.x,l=o-e.y;s.z=-n,s.y=l,t.rotate(s),t.draw(),e.x=r,e.y=o}})),$("#rubik-cube").on("touchstart",(function(t){var i=t.originalEvent.changedTouches[0].pageX,r=t.originalEvent.changedTouches[0].pageY;!1===s&&(e.x=i,e.y=r),s=!0,t.preventDefault()})),$("#rubik-cube").on("touchend",(function(e){if(!0===s){s=!1,t.resetRotation();const i={x:20,y:20,z:20};t.rotate(i),t.draw(),e.preventDefault()}})),$("#rubik-cube").on("touchmove",(function(i){if(!0===s){const s={x:0,y:0,z:0};var r=i.originalEvent.changedTouches[0].pageX,o=i.originalEvent.changedTouches[0].pageY;let n=r-e.x,l=o-e.y;s.z=-n,s.y=l,t.rotate(s),t.draw(),console.info(n),e.x=r,e.y=o}}));var i=function(t,e){this.x=t,this.y=e};let r=!1,o=new Array;function n(t,e,s){const r=$("#penColor").val();s.strokeStyle=r;const n=$("#penWidth").val();s.lineWidth=parseInt(n),s.beginPath();var l=o[o.length-1];s.moveTo(l.x,l.y),s.lineTo(t,e),s.closePath(),s.stroke(),o.push(new i(t,e))}$(".cube-block").mousedown((function(e){if(1==e.which){r=!0;var s=e.pageX-this.offsetLeft,l=e.pageY-this.offsetTop;o.push(new i(s,l)),$(e.target).mousemove((function(t){r&&n(t.pageX-this.offsetLeft,t.pageY-this.offsetTop,t.currentTarget.getContext("2d"))})),$(window).mouseup((function(e){r=!1,t.draw(),$(e.target).off("mousemove")}))}})),$(".cube-block").on("touchstart",(function(e){var s=e.originalEvent.changedTouches[0].pageX-this.offsetLeft,l=e.originalEvent.changedTouches[0].pageY-this.offsetTop;r=!0,o.push(new i(s,l)),e.preventDefault(),$(e.target).on("touchmove",(function(t){r&&n(t.originalEvent.changedTouches[0].pageX-this.offsetLeft,t.originalEvent.changedTouches[0].pageY-this.offsetTop,t.currentTarget.getContext("2d"))})),$(window).mouseup((function(e){r=!1,t.draw(),$(e.target).off("touchmove")}))}))}}const d={黑:"black",白:"white",红:"red",蓝:"blue",黄:"yellow"};class g{constructor(t,e,s,i,r){this.n=e,this.m=s,this.filledArea=[],this.noMeet=!1,this.hashi=new Set,this.hashiRules=[],this.globalRules=i,this.globalFinalRules=r;const o=[];for(let e=0;e<t.length;e++){const s=t[e].replace(/\s/g,"");"没"==s[0]||s.includes("空白的格子")?o.push(s):this.parseLine(s)}for(const t of o)this.parseLine(t);this.hashiRules.length>0&&this.handleHashi(i)}handleHashi(t){const e=[],s=[],i=[],r=[];for(const o of this.hashiRules)for(let l=0;l<o.restrictAreas.length;l++){const h=o.restrictAreas[l],a=[h],u=(m,h%m);let c=!1,f=!1,p=!1,d=!1;const g={u:null,d:null,l:null,r:null,self:h};for(let t=h-m;t>=0;t-=m)if(this.hashi.has(t)){p=!0,a.push(t),g.u=t;break}for(let t=h+m;t<n*m;t+=m)if(this.hashi.has(t)){d=!0,a.push(t),g.d=t;break}if(d){r.push(h);for(let t=h;t<n*m&&t!=g.d;t+=m)e[t]={u:h,d:g.d,rule:o.rules}}for(let t=u-1,e=h-1;t>=0;t--,e--)if(this.hashi.has(e)){c=!0,a.push(e),g.l=e;break}for(let t=u+1,e=h+1;t<m;t++,e++)if(this.hashi.has(e)){f=!0,a.push(e),g.r=e;break}if(f){i.push(h);for(let t=u,e=h;t<m&&e!=g.r;t++,e++)s[e]={l:h,r:g.r,rule:o.rules}}const b=o.rules.hashi.limit,w=o.rules.hashi.number,y=[];for(let t=0;t<=b[0]&&!(t>w)&&(p||!(t>0));t++)for(let e=0;e<=b[1]&&!(t+e>w)&&(d||!(e>0));e++)for(let s=0;s<=b[2]&&(c||!(s>0));s++){const i=w-t-e-s;if(i<0)break;!f&&i>0||i>b[3]||y.push({hashi:{u:t,d:e,l:s,r:i},to:g})}o.rules.set=y,o.rules.hashi.to=g,o.rules.hashi.conflict={},t.push({restrictAreas:a,rules:o.rules})}if(this.noMeet){for(const t of i){const i=s[t].rule,r=[];for(let i=t+1;s[i]&&s[t].r!==i;i++)e[i]&&r.push(e[i].rule.hashi);r.length>0&&(i.hashi.conflict.r={rules:r})}for(const t of r){const i=e[t].rule,r=[];for(let i=t+m;i<n*m&&i!==e[t].d;i+=m)s[i]&&r.push(s[i].rule.hashi);r.length>0&&(i.hashi.conflict.d={rules:r})}}}parseLine(t,e,s){const i=e||this.globalFinalRules,r=s||this.globalRules;if(""===t)return;if(this.specialRule(t))return;const o=this.getRestrictAreas(t,0),n=this.getRules(t,o.stopPos);if(void 0!==n)if(n.hashi)for(let t=0;t<o.restrictArea.length;t++){for(const e of o.restrictArea[t])this.hashi.add(e);this.hashiRules.push({restrictAreas:o.restrictArea[t],rules:n})}else if(n.smallerThan||n.largerThan)for(let t=0;t<o.restrictArea.length;t++)i.push({restrictAreas:o.restrictArea[t],rules:n});else for(let t=0;t<o.restrictArea.length;t++)r.push({restrictAreas:o.restrictArea[t],rules:n});else alert(`我不认识"${t}"的规则，请仔细检查`)}parseRelativeSign(t,e){return"是"===t[e]?{set:this.getSet(t,e+1)}:"大"===t[e]?{largerThan:this.getNumber(t,e+2).value}:"大"===t[e]&&"等"===t[e+2]?{largerThan:this.getNumber(t,e+4).value-1}:"小"===t[e]?{smallerThan:this.getNumber(t,e+2).value}:"小"===t[e]&&"等"===t[e+2]?{smallerThan:this.getNumber(t,e+4).value+1}:"强"===t[e]?{set:this.getSet(t,e+3),force:!0}:void 0}getRules(t,e){let s;if("互"===t[e])return{isDifferent:!0};if("按"===t[e]&&"顺"===t[e+1])return{isWord:!0};if(s=this.parseRelativeSign(t,e))return s;if("的"===t[e]&&"和"===t[e+1])return{sum:this.getNumber(t,e+3).value};if("的"===t[e]&&"系"===t[e+1]){const s=this.getNumberList(t,e+4),i=this.getNumber(t,s.stopPos+6);return{linear:{coefficient:s.set.map((t=>t+1)),result:i.value}}}if("的"===t[e]){const s=this.getNumber(t,e+1);let i,r;s?(i=s.stopPos+3,r=s.value):(i=e+6,r=d[t[e+1]]);const o={count:this.parseRelativeSign(t,i)};return o.count.item=r,o}if("从"===t[e])return{bars:{list:this.getNumberList(t,e+12).set.map((t=>t+1)),type:"上"===t[e+1]?"col":"row",item:d[t[e+7]]}};if("除"===t[e]){const s=this.getNumberList(t,e+9).set;return{permutation:{list:s},set:s}}if("可"===t[e]&&"形"===t[e+2])return{loop:{number:this.getNumber(t,e+4).value},set:["UR","UB","UL","RB","RL","BL"]};if("连"===t[e]){const s=this.getNumber(t,e+8),i=this.getNumberList(t,s.stopPos+12).set;return{hashi:{number:s.value,limit:i.map((t=>t+1))}}}}getNumber(t,e){const s=t.substr(e).match(/^\-*\d+/);return s?{value:parseInt(s[0]),stopPos:e+s[0].length}:null}getNumberList(t,e){let s=e+1;const i=[];for(;;){let e=this.getNumber(t,s);if(e)s=e.stopPos+1,i.push(e.value-1);else{const r=s;for(;"]"!=t[s]&&","!=t[s];)s++;i.push(t.slice(r,s)),e={stopPos:s},s++}if("]"===t[e.stopPos])return{stopPos:e.stopPos+1,set:i}}}getOriginAreas(t,e){const s=[];if("每"===t[0]){if("一行"===t.substr(1,2)){for(let t=0;t<this.n;t++){s.push([]);for(let e=0;e<this.m;e++)s[t].push(t*this.m+e)}return{stopPos:3,restrictArea:s}}if("一列"===t.substr(1,2)){for(let t=0;t<this.n;t++){s.push([]);for(let e=0;e<this.m;e++)s[t].push(e*this.m+t)}return{stopPos:3,restrictArea:s}}if("一格"===t.substr(1,2)){for(let t=0;t<this.n;t++)for(let e=0;e<this.m;e++)s.push(t*this.m+e);return{stopPos:3,restrictArea:[s]}}}else if("第"===t[0]){const i=this.getNumber(t,1);if(i)if(this.filledArea[i.value-1]=!0,"行"===t[i.stopPos])for(let t=0;t<this.m;t++)this.filledArea[(i.value-1)*m+t]=!0,s.push((i.value-1)*m+t);else if("列"===t[i.stopPos])for(let t=0;t<this.n;t++)this.filledArea[t*this.m+(i.value-1)]=!0,s.push(t*this.m+(i.value-1));else"格"===t[i.stopPos]&&s.push(i.value-1);else if("["===t[e+1]){const s=this.getNumberList(t,e+1);return{stopPos:s.stopPos+1,restrictArea:[s.set]}}return{stopPos:i.stopPos+1,restrictArea:[s]}}}getDir(t,e){if("本"===t[e])return{stopPos:e+2,diff:{dr:0,dc:0}};let s=e,i=0,r=0;for(;;){let e=0;switch(t[s]){case"上":i--;break;case"下":i++;break;case"左":r--;break;case"右":r++;break;default:e=1}if(1===e)break;s++}return{stopPos:s,diff:{dr:i,dc:r}}}modifyArea(t,e,s){if("["===t[e]){let s=e+1;const i=[];for(;;){const e=this.getDir(t,s);if(i.push(e.diff),s=e.stopPos+1,"]"===t[e.stopPos])break}return{diffs:i,stopPos:s}}}getRestrictAreas(t,e){const s=this.getOriginAreas(t,e);if("的"===t[s.stopPos]&&"["===t[s.stopPos+1]){let e=this.modifyArea(t,s.stopPos+1,s);const i=s.restrictArea[0].map((t=>{let s=t%this.m,i=parseInt(t/this.m);const r=[];for(const t of e.diffs){const e=s+t.dc,o=i+t.dr;e<0||e>=this.m||o<0||o>=this.n||r.push(o*this.m+e)}return r}));s.restrictArea=i,s.stopPos=e.stopPos}else if("空"==t[s.stopPos]){const t=[];for(const e of s.restrictArea){const s=[];for(const t of e)this.filledArea[t]||s.push(t);t.push(s)}s.restrictArea=t,s.stopPos+=5}return s}getSet(t,e){const s=[];let i=e;for(;t[i];){const e=this.getNumber(t,i);if(e)s.push(e.value),i=e.stopPos;else if("从"===t[i]){let e,r=this.getNumber(t,i+1);if(null===r){r=t[i+1],"到"===t[i+2]&&(e=t[i+3]);for(let t=r.charCodeAt(0);t<=e.charCodeAt(0);t++)s.push(String.fromCharCode(t).toLowerCase());i+=4}else{"到"===t[r.stopPos]&&(e=this.getNumber(t,r.stopPos+1));for(let t=r.value;t<=e.value;t++)s.push(t);i=e.stopPos+3}}else if("或"===t[i])i++;else if("黑"===t[i])s.push("black"),i+=2;else if("白"===t[i])s.push("white"),i+=2;else if("红"===t[i])s.push("red"),i+=2;else if("蓝"===t[i])s.push("blue"),i+=2;else{if(!t[i].match(/[a-z]/i))break;s.push(t[i]),i+=1}}return s}specialRule(t){if("我"===t[0])return!0;if("如"===t[0]){const e=t.match(/^如果(?<ifCondition>(?<![,，]).*),那么(?<statement>.*)/).groups,s=e.ifCondition,i=e.statement;void 0!==s&&void 0!==i||alert(t+"不符合如果这条规则的规范");const r=[];this.parseLine(s,r,r);const o=[];this.parseLine(i,o,o);for(const t of r){const e={restrictAreas:t.restrictAreas,rules:{ifCondition:{condition:t.rules,statement:o}}};this.globalRules.push(e)}return!0}if("没"===t[0]){let e=t.substr(9);e=e.substr(0,e.length-1);for(let t=0;t<this.n*this.m;t++){if(this.filledArea[t])continue;const s=e.replace("<格子序号>",(t+1).toString());this.parseLine(s)}return!0}return"线"===t[0]&&(this.noMeet=!0,!0)}}class b{constructor(){this.possibleArray=[],this.connectedRules=[],this.globalRules=[],this.globalFinalRules=[],this.weight=[]}handleLoop(t,e){const s=new Set(t),i=this.globalRules,r=this.n,o=this.m;for(const n of t){let t=[...this.possibleArray[n]];const l=n/o,h=n%o,a=[n];0!=l&&s.has(n-o)?a.push(n-o):t=t.filter((t=>!t.includes("U"))),0!=h&&s.has(n-1)?a.push(n-1):t=t.filter((t=>!t.includes("L"))),l!=r-1&&s.has(n+o)?a.push(n+o):t=t.filter((t=>!t.includes("B"))),h!=o-1&&s.has(n+1)?a.push(n+1):t=t.filter((t=>!t.includes("R"))),this.possibleArray[n]=new Set(t);const u={restrictAreas:a,rules:{loop:e.rules.loop}};i.push(u)}e.rules.loop.areasSet=new Set(s)}async tryProcess(){const t=this.n,e=this.m;for(let s=0;s<t*e;s++){const t=this.possibleArray[s];if(t.size<=1)continue;const e=[];for(const i of t){this.possibleArray[s]=new Set([i]);const t=[],r=[];let o=!1;for(let e=0;e<this.connectedRules[s].length;e++){const i=this.relaxRule(this.globalRules[this.connectedRules[s][e]],t,this.connectedRules[s][e],r);if(this.resumePossible(t,r),-1===i){o=!0;break}}!1===o&&e.push(i)}this.possibleArray[s]=new Set(e)}return this.relax()}async solve(t,e,s,i){this.n=e,this.m=s,this.callback=i;const r=this.possibleArray,o=this.connectedRules,n=this.globalRules,l=this.globalFinalRules;new g(t,e,s,n,l);for(let t=0;t<e*s;t++)r.push(void 0),o.push([]),this.weight.push(0);n.descriptionRules=[],n.groupRules=[];const h=[];for(let t=0;t<n.length;t++){const e=n[t],{restrictAreas:s}=e,i=e.rules?e.rules.set:void 0;if(i){if(n.descriptionRules.push(t),e.rules.force){h.push(t);continue}if(e.rules.hashi)this.mergeSet(s[0],i);else for(let t=0;t<s.length;t++)this.mergeSet(s[t],i);if(e.rules.loop){this.handleLoop(s,e);continue}if(1==Object.keys(e.rules).length)continue}n.groupRules.push(t);for(let e=0;e<s.length;e++)o[s[e]].push(t),this.weight[s[e]]++}for(let t=0;t<l.length;t++){const e=l[t],{restrictAreas:s}=e;if(e.rules&&e.rules.largerThan)for(let t=0;t<s.length;t++)r[s[t]]=this.largerSet(r[s[t]],e.rules.largerThan);else if(e.rules&&e.rules.smallerThan)for(let t=0;t<s.length;t++)r[s[t]]=this.smallSet(r[s[t]],e.rules.smallerThan)}for(const t of h){const e=n[t],{restrictAreas:s}=e;for(let t=0;t<s.length;t++)this.possibleArray[s[t]]=new Set(e.rules.set)}this.hasLoop=!1;let a=this.relax();-1!=a&&this.hasLoop&&(a=await this.tryProcess()),$("#sudokuAnswer").html(""),-1!=a&&await this.dfs(),$("#sudokuAnswer").append("已找到所有解")}relaxDifference(t,e,s){let i=[];const r=new Map;for(let e=0;e<t.length;e++){const s=[...this.possibleArray[t[e]]];for(let t=0;t<s.length;t++){const e=r.get(s[t]);e?r.set(s[t],e+1):r.set(s[t],1)}}r.forEach(((i,r)=>{if(1===i)for(let i=0;i<t.length;i++){const o=t[i],n=this.possibleArray[o];if(n.size>1&&n.has(r)){e[o]||(e[o]=new Set(n)),this.possibleArray[o]=new Set([r]);for(const t of this.connectedRules[o])s.add(t)}}}));for(let e=0;e<t.length;e++)if(1===this.possibleArray[t[e]].size){const s=this.possibleArray[t[e]].values().next().value;if(i.includes(s))return-1;i.push(s)}for(let r=0;r<i.length;r++)for(let o=0;o<t.length;o++){const n=this.possibleArray[t[o]];if(n.size>1&&n.has(i[r])){if(e[t[o]]||(e[t[o]]=new Set(n)),n.delete(i[r]),0===n.size)return console.info("No"),-1;for(const e of this.connectedRules[t[o]])s.add(e);1===n.size&&i.push(n.values().next().value)}}i=[];for(let e=0;e<t.length;e++)if(1===this.possibleArray[t[e]].size){const s=this.possibleArray[t[e]].values().next().value;if(i.includes(s))return-1;i.push(s)}return 1}relaxSum(t,e,s,i){const r=i.rules.sum;let o,n=0,l=t.length,h=0,a=0,u=0;const c=[],f=[];for(let e=0;e<t.length;e++){const s=[...this.possibleArray[t[e]]];if(0===s.length)return-1;let i=s[0],r=s[0];for(const t of s)t>i&&(i=t),t<r&&(r=t);c[e]=i,f[e]=r,a+=i,u+=r,s.length>1?(h=t[e],o=void 0):(o=o?o+s[0]:s[0],l--,n+=s[0])}for(let i=0;i<t.length;i++){const n=this.possibleArray[t[i]],l=[];for(const t of n)(a+t-c[i]<r||u+t-f[i]>r)&&l.push(t);if(void 0!==o&&o!==r)return-1;if(a<r||u>r)return-1;if(l.length>0){e[t[i]]||(e[t[i]]=new Set(n));for(const e of this.connectedRules[t[i]])s.add(e);for(const t of l)n.delete(t)}}if(1===l){if(!this.possibleArray[h].has(r-n))return-1;e[h]||(e[h]=new Set(possibleList));for(const t of this.connectedRules[h])s.add(t);this.possibleArray[h]=new Set([r-n])}return 1}relaxCount(t,e,s,i){let r=0,o=!0,n=0;for(let e=0;e<t.length;e++){const i=this.possibleArray[t[e]];if(i.size<=0)return-1;i.has(s.item)&&n++,1===i.size?i.values().next().value===s.item&&r++:o=!1}if(s.set){const l=s.set[0];if(n<l)return-1;if(o&&r!==l)return-1;if(o||n!==l){if(!o&&r===l)for(let r=0;r<t.length;r++){const o=this.possibleArray[t[r]];if(o.length>1&&o.has(s.item)){e[t[r]]||(e[t[r]]=new Set(o)),o.delete(s.item);for(const e of this.connectedRules[t[r]])i.add(e)}}}else for(let r=0;r<t.length;r++){const o=this.possibleArray[t[r]];if(o.size>1&&o.has(s.item)){e[t[r]]||(e[t[r]]=this.possibleArray[t[r]]);for(const e of this.connectedRules[t[r]])i.add(e);this.possibleArray[t[r]]=new Set([s.item])}}}}relaxLinear(t,e,s,i){let r=0,o=0,n=0;e.length;const l=[],h=[];for(let s=0;s<e.length;s++){const i=this.possibleArray[e[s]];if(i.size<=0)return-1;if(i.size>1)return;r+=i.values().next().value*t.coefficient[s]}if(r!==t.result)return-1;for(let s=0;s<e.length;s++){const i=[...this.possibleArray[e[s]]];if(0===i.length)return-1;let r=i[0],a=i[0];for(const e of i){const i=e*t.coefficient[s];i>r&&(r=i),i<a&&(a=i)}l[s]=r,h[s]=a,o+=r,n+=a}return o<t.result||n>t.result?-1:void 0}isSatisfied(t,e){const s=[];for(const e of t){if(1!==this.possibleArray[e].size)return-1;s.push(this.possibleArray[e].values().next().value)}if(e.set){for(const t of s)if(!e.set.includes(t))return 0}else if(e.largerThan){for(const t of s)if(t<=e.largerThan)return 0}else if(e.smallerThan){for(const t of s)if(t>=e.smallerThan)return 0}else if(e.sum){let t=0;for(const e of s)t+=e;if(t!==e.sum)return 0}return 1}relaxIfCondition(t,e,s,i,r){if(1===this.isSatisfied(e,t.condition))for(const e of t.statement){const t=this.isSatisfied(e.restrictAreas,e.rules);if(0===t)return-1;if(-1===t){if(e.rules.sum){this.globalRules.push(e);const t=this.globalRules.length-1;r[t]=[];for(const s of e.restrictAreas)this.connectedRules[s].push(t),r[t].push(s)}for(const t of e.restrictAreas)if(1!==this.possibleArray[t].size){s[t]||(s[t]=new Set(this.possibleArray[t]));for(const e of this.connectedRules[t])i.add(e);e.rules.set?this.possibleArray[t]=new Set(e.rules.set):e.rules.largerThan?this.possibleArray[t]=this.largerSet(this.possibleArray[t],e.rules.largerThan):e.rules.smallerThan&&(this.possibleArray[t]=this.smallSet(this.possibleArray[t],e.rules.smallerThan))}}}}relaxWord(t,e,s){const i=[];for(const e of t)i.push(this.possibleArray[e]);const r=window.Trie.findAllByPossibleSets(i);if(console.info(r),!(r.length>=1e3))for(let o=0;o<t.length;o++){const n=new Set;for(const t of r)n.add(t[o]);if(new Set([...n].filter((t=>i[o].has(t)))).size!==this.possibleArray[t[o]].size){e[t[o]]||(e[t[o]]=new Set(this.possibleArray[t[o]]));for(const e of this.connectedRules[t[o]])s.add(e);this.possibleArray[t[o]]=new Set([...n].filter((t=>i[o].has(t))))}}}relaxBars(t,e,s,i){console.info(t,e,s,i);const r=[0],o=t.length,n=i.list.length;let l=0;const h=[],a=[],u=[],c=[];for(let t=0;t<=o;t++)h.push(!1),a.push(!1),c.push(!1);for(let e=0;e<t.length;e++){const s=t[e];this.possibleArray[s].has(i.item)&&(l++,1===this.possibleArray[s].size&&(c[e+1]=!0)),r.push(l)}const f=[[]],p=[[]];for(let t=0;t<=n;t++)f[0].push(!1),p[0].push(!1);p[0][0]=!0;for(let t=0;t<=n;t++)u.push(o+2);for(let t=1;t<=o;t++){f.push([!1]),c[t]?p.push([!1]):p.push([p[t-1][0]]);for(let e=1;e<=n;e++){let s=!1;t-i.list[e-1]>=0&&r[t]-r[t-i.list[e-1]]===i.list[e-1]&&(s=!0),s?t!=o&&!0===c[t+1]?f[t].push(!1):f[t].push(p[t-i.list[e-1]][e-1]):f[t].push(!1),c[t]?p[t].push(!1):p[t].push(p[t-1][e]||f[t-1][e])}}for(let t=n;t>=1;t--)for(let e=u[t]-2;e>=1;e--)if(f[e][t]){u[t-1]=e-i.list[t-1]+1;break}for(let t=o;t>=1;t--){t<u[0]&&!1===c[t]&&(h[t]=!0);for(let e=n;e>=1;e--){if(f[t][e]&&t<u[e]-1)for(let s=t;s>=t-i.list[e-1]+1;s--)a[s]=!0;p[t][e]&&t<u[e]&&!1===c[t]&&(h[t]=!0)}}for(let e=1;e<=o;e++){const s=this.possibleArray[t[e-1]];if(a[e]&&!h[e]&&!s.has(i.item))return-1;if(!a[e]&&h[e]&&s.has(i.item)&&1===s.size)return-1;if(!a[e]&&!h[e])return-1;if(!a[e]&&c[e])return-1}for(let r=1;r<=o;r++){if(a[r]&&!h[r]&&this.possibleArray[t[r-1]].size>1){e[t[r-1]]||(e[t[r-1]]=new Set(this.possibleArray[t[r-1]]));for(const e of this.connectedRules[t[r-1]])s.add(e);this.possibleArray[t[r-1]]=new Set([i.item])}if(!a[r]&&h[r]&&this.possibleArray[t[r-1]].has(i.item)){e[t[r-1]]||(e[t[r-1]]=new Set(this.possibleArray[t[r-1]]));for(const e of this.connectedRules[t[r-1]])s.add(e);this.possibleArray[t[r-1]].delete(i.item)}}}relaxPermutation(t,e,s,i){const r=Array.from(i.list),o=(t.length,[]),n=[];for(const e of t)if(1===this.possibleArray[e].size){const t=this.possibleArray[e].values().next().value;if("black"===t)continue;n.push(t)}else o.push(e);for(const t of n){let e=!1;for(let s=0;s<r.length;s++)if(t===r[s]){r.splice(s,1),e=!0;break}if(!e)return-1}const l=[];for(const t of n){let e=!1;for(let s=0;s<r.length;s++)if(t===r[s]){e=!0;break}e||l.push(t)}for(const t of o)for(const i of l)if(this.possibleArray[t].has(i)){e[t]||(e[t]=new Set(this.possibleArray[t]));for(const e of this.connectedRules[t])s.add(e);this.possibleArray[t]}}relaxLoop(t,e,s,i){const r={U:"B",L:"R",R:"L",B:"U"},o={U:0,B:1,L:2,R:3},n=["U","B","L","R"],l=[-this.m,this.m,-1,1],h=t[0];let a=[...this.possibleArray[h]];const u={};for(const t of a)2==t.length&&(u[t[0]]=(u[t[0]]||0)+1,u[t[1]]=(u[t[1]]||0)+1);const c=a.length,f=(t,e,s)=>{let i=t,n=s,h=0;for(;;){if(i==e)return h+1;if(!i||1!=this.possibleArray[i].size)return;const t=this.possibleArray[i].values().next().value.replace(n,"");i+=l[o[t]],n=r[t],h++}};let p=[],d=[];for(let s=0;s<4;s++){const o=n[s],c=l[s],f=h+c;if(-1==t.indexOf(h+c))continue;const g=r[o];let b=[...this.possibleArray[f]];if(u[o])if(u[o]===a.length){if(b.filter((t=>t.includes(g))).length<=0)return-1;if(b=b.filter((t=>t.includes(g))),this.possibleArray[f].size!=b.length){e[f]||(e[f]=new Set(this.possibleArray[f]));for(const t of this.connectedRules[f])i.add(t);this.possibleArray[f]=new Set(b)}}else b.filter((t=>t.includes(g))).length<=0&&p.push(o),0==b.filter((t=>!t.includes(g))).length&&d.push(o);else{if(b.filter((t=>!t.includes(g))).length<=0)return-1;if(b=b.filter((t=>!t.includes(g))),this.possibleArray[f].size!=b.length){e[f]||(e[f]=new Set(this.possibleArray[f]));for(const t of this.connectedRules[f])i.add(t);this.possibleArray[f]=new Set(b)}}}for(const t of p)a=a.filter((e=>!e.includes(t)));for(const t of d)a=a.filter((e=>e.includes(t)));if(1==s.number)for(let t=0;t<a.length;t++){const e=a[t];if("UR"==e||"UL"==e)continue;const i=h+l[o[e[0]]],n=h+l[o[e[1]]],u=[...this.possibleArray[i]].filter((t=>t.includes(r[e[0]]))),c=[...this.possibleArray[n]].filter((t=>t.includes(r[e[1]])));if(1!=u.length||1!=c.length)continue;const p=this.possibleArray[i];this.possibleArray[i]=new Set(u);const d=f(i,n,r[e[0]]);d&&d+1!=s.areasSet.size&&(a[t]=""),this.possibleArray[i]=p}if(a=a.filter((t=>""!=t)),c>a.length){e[h]||(e[h]=new Set(this.possibleArray[h]));for(const t of this.connectedRules[h])i.add(t);this.possibleArray[h]=new Set(a)}}relaxHashi(t,e,s,i){const r=["u","d","l","r"],o={u:"d",d:"u",l:"r",r:"l"},n=s.to,l=this.possibleArray[t[0]],h=(t,e)=>new Set(e.filter((e=>t.includes(e)))),a=(t,e)=>{const s=[];for(const i of t)s.push(i.hashi[e]);return s};for(const s of r){const r=n[s];if(!r)continue;const u=[...this.possibleArray[r]],c=o[s],f=h(a(l,s),a(u,c));for(const r of l)if(!f.has(r.hashi[s])){e[t[0]]||(e[t[0]]=new Set(this.possibleArray[t[0]]));for(const e of this.connectedRules[t[0]])i.add(e);this.possibleArray[t[0]].delete(r)}for(const t of u)if(!f.has(t.hashi[c])){e[r]||(e[r]=new Set(this.possibleArray[r]));for(const t of this.connectedRules[r])i.add(t);this.possibleArray[r].delete(t)}}if(s.conflict){if(s.conflict.d){const i=s.conflict.d.rules;let r=!1;if(i)for(const t of i)if(0===[...this.possibleArray[t.to.self]].filter((t=>!t.hashi.r)).length){r=!0;break}if(r){const s=[...this.possibleArray[t[0]]].filter((t=>!t.hashi.d));if(0===s.length)return-1;s.length<this.possibleArray[t[0]].size&&(e[t[0]]||(e[t[0]]=new Set(this.possibleArray[t[0]])),this.possibleArray[t[0]]=new Set(s))}}if(s.conflict.r){const i=s.conflict.r.rules;let r=!1;if(i)for(const t of i)if(0===[...this.possibleArray[t.to.self]].filter((t=>!t.hashi.d)).length){r=!0;break}if(r){const s=[...this.possibleArray[t[0]]].filter((t=>!t.hashi.r));if(0===s.length)return-1;s.length<this.possibleArray[t[0]].size&&(e[t[0]]||(e[t[0]]=new Set(this.possibleArray[t[0]])),this.possibleArray[t[0]]=new Set(s))}}}}relaxRule(t,e,s,i){const r=new Set([]),o=t.restrictAreas;if(t.rules.isDifferent){if(-1===this.relaxDifference(o,e,r))return-1}else if(t.rules.sum){if(-1===this.relaxSum(o,e,r,t))return-1}else if(t.rules.count){if(-1===this.relaxCount(o,e,t.rules.count,r))return-1}else if(t.rules.linear){if(-1===this.relaxLinear(t.rules.linear,o,e,r))return-1}else if(t.rules.ifCondition){if(-1===this.relaxIfCondition(t.rules.ifCondition,o,e,r,i))return-1}else if(t.rules.isWord){if(-1===this.relaxWord(o,e,r))return-1}else if(t.rules.bars){if(-1===this.relaxBars(o,e,r,t.rules.bars))return-1}else if(t.rules.permutation){if(-1===this.relaxPermutation(o,e,r,t.rules.permutation))return-1}else if(t.rules.loop){if(-1===this.relaxLoop(o,e,t.rules.loop,r))return-1;this.hasLoop=!0}else if(t.rules.hashi&&-1===this.relaxHashi(o,e,t.rules.hashi,r))return-1;for(const t of r)if(s!==t&&-1===this.relaxRule(this.globalRules[t],e,t,i))return-1;return 1}print(){const t=[];let e="",s=[];$("#showcase .vertical-").remove(),$("#showcase .horizon-").remove();let i=!1;for(let r=0;r<this.possibleArray.length;r++){const o=this.possibleArray[r];if(!o||1!=o.size)continue;const n=o?o.values().next().value:" ";if(n.hashi){i=!0;const t=n.to.r,e=n.hashi.r,s=n.to.d,o=n.hashi.d;if(e){let s=r+1;$(`#showcase .sudoku-grid #grid-${s}`).html("");const i=100/(e+1);for(;s!=t;){for(let t=0;t<e;t++)$(`#showcase .sudoku-grid #grid-${s}`).append(`<div class="horizon-" style="top:${i*(t+1)}%"></div>`);s++}}if(o){let t=r+this.m;$(`#showcase .sudoku-grid #grid-${t}`).html("");const e=100/(o+1);for(;t!=s;){for(let s=0;s<o;s++)$(`#showcase .sudoku-grid #grid-${t}`).append(`<div class="vertical-" style="left:${e*(s+1)}%"></div>`);t+=this.m}}}else"black"===n?($(`#showcase .sudoku-grid #grid-${r}`).css("background-color",n),$(`#showcase .sudoku-grid #grid-${r}`).css("color","white"),i=!0):"white"===n?($(`#showcase .sudoku-grid #grid-${r}`).css("background-color",n),$(`#showcase .sudoku-grid #grid-${r}`).css("color","black"),i=!0):2==n.length?(i=!0,$(`#showcase .sudoku-grid #grid-${r}`).attr("class","sudoku-grid-content "+n),$(`#showcase .sudoku-grid #grid-${r}`).css("color","white")):$(`#showcase .sudoku-grid #grid-${r}`).css("background-color",n);s.push(n),e+=n+" ",r%this.m==this.m-1&&(t.push(s),e+="\n",s=[])}if(i){const t=$("#showcase #sudokuContainer").clone();$("#sudokuAnswer").append(t);for(let e=0;e<this.possibleArray.length;e++){const s=this.possibleArray[e];if(!s||1!=s.size)continue;const i=s?s.values().next().value:" ";i.hashi||2!==i.length&&"black"!=i&&"white"!=i&&"red"!=i&&t.find(`.sudoku-grid #grid-${e}`).html(i.toString())}}else $("#sudokuAnswer").append(e+"\n-----------------------\n")}relax(){for(let t=0;t<this.globalRules.groupRules.length;t++){const e=this.globalRules[this.globalRules.groupRules[t]],s=this.relaxRule(e,[],this.globalRules.groupRules[t],[]);if(-1==s)return s}}mergeSet(t,e){var s;void 0===this.possibleArray[t]?this.possibleArray[t]=new Set(e):this.possibleArray[t]=(s=this.possibleArray[t],new Set(e.filter((t=>s.has(t)))))}getSmallestGrid(){let t=-1,e=1024,s=0;for(let i=0;i<this.possibleArray.length;i++){const r=this.possibleArray[i]?this.possibleArray[i].size:1,o=this.weight[i];if(1!==r&&((r<e||r==e&&o>s)&&(s=o,e=r,t=i),2===e&&0!=o))return t}return t}async dfs(){const t=this.getSmallestGrid();if(-1===t)return this.print(),await this.callback(),confirm("发现了一个解，是否继续寻找下一个解?(可能耗时很久)")?0:-1;const e=this.possibleArray[t];for(const s of e.values()){const e=[],i=[];if(e[t]=new Set(this.possibleArray[t]),this.possibleArray[t]=new Set([s]),this.connectedRules[t]){let s=!1;for(let r=0;r<this.connectedRules[t].length;r++)if(-1===this.relaxRule(this.globalRules[this.connectedRules[t][r]],e,this.connectedRules[t][r],i)){this.resumePossible(e,i),s=!0;break}if(!0===s)continue}const r=await this.dfs();if(-1===r)return r;this.resumePossible(e,i)}this.possibleArray[t]=e}resumePossible(t,e){t.forEach(((t,e)=>{this.possibleArray[e]=t})),e.forEach(((t,e)=>{for(const e of t)this.connectedRules[e].pop();this.globalRules.pop()}))}largerSet(t,e){const s=new Set([]);for(const i of t)i>e&&s.add(i);return s}smallSet(t,e){const s=new Set([]);for(const i of t)i<e&&s.add(i);return s}}})(),__webpack_exports__})()));